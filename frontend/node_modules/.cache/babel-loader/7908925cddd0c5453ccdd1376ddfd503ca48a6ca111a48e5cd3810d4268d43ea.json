{"ast":null,"code":"// MediaStorage.js - Умное локальное хранилище для MVP\nclass MediaStorage {\n  constructor() {\n    this.dbName = 'VideoEditorDB';\n    this.version = 1;\n    this.db = null;\n    this.fallbackMode = false;\n    this.memoryStorage = new Map();\n    this.limits = {\n      videos: 5,\n      images: 10,\n      audios: 5,\n      maxFileSize: 100 * 1024 * 1024,\n      // 100MB\n      retentionDays: 7\n    };\n  }\n\n  // Проверка поддержки IndexedDB\n  isIndexedDBSupported() {\n    return 'indexedDB' in window && indexedDB !== null;\n  }\n\n  // Инициализация IndexedDB или fallback\n  async init() {\n    if (!this.isIndexedDBSupported()) {\n      console.warn('IndexedDB not supported, using fallback mode');\n      this.fallbackMode = true;\n      return this.initFallback();\n    }\n    try {\n      return await this.initIndexedDB();\n    } catch (error) {\n      console.warn('IndexedDB initialization failed, switching to fallback mode:', error);\n      this.fallbackMode = true;\n      return this.initFallback();\n    }\n  }\n\n  // Инициализация IndexedDB\n  async initIndexedDB() {\n    return new Promise((resolve, reject) => {\n      try {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          var _request$error;\n          console.error('IndexedDB error:', request.error);\n          reject(new Error(`IndexedDB error: ${((_request$error = request.error) === null || _request$error === void 0 ? void 0 : _request$error.message) || 'Unknown error'}`));\n        };\n        request.onsuccess = () => {\n          this.db = request.result;\n          console.log('IndexedDB initialized successfully');\n          resolve(this.db);\n        };\n        request.onupgradeneeded = event => {\n          try {\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains('files')) {\n              const fileStore = db.createObjectStore('files', {\n                keyPath: 'id'\n              });\n              fileStore.createIndex('type', 'type');\n              fileStore.createIndex('createdAt', 'createdAt');\n              console.log('IndexedDB store created');\n            }\n          } catch (upgradeError) {\n            console.error('IndexedDB upgrade error:', upgradeError);\n            reject(upgradeError);\n          }\n        };\n        request.onblocked = () => {\n          console.warn('IndexedDB blocked - another tab may be open');\n          reject(new Error('IndexedDB blocked by another tab'));\n        };\n      } catch (error) {\n        console.error('IndexedDB initialization error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Инициализация fallback режима\n  async initFallback() {\n    console.log('Initializing fallback storage mode');\n    this.fallbackMode = true;\n\n    // В fallback режиме мы не можем восстановить blob объекты из localStorage\n    // Поэтому просто очищаем память\n    this.memoryStorage.clear();\n\n    // Очищаем старые метаданные из localStorage для избежания путаницы\n    try {\n      localStorage.removeItem('mediaFiles');\n      console.log('Cleared old localStorage data for fresh start');\n    } catch (error) {\n      console.warn('Failed to clear localStorage:', error);\n    }\n    return true;\n  }\n\n  // Сохранить файл\n  async saveFile(file, type) {\n    // Проверяем размер файла\n    if (file.size > this.limits.maxFileSize) {\n      throw new Error(`File too large. Max size: ${this.limits.maxFileSize / (1024 * 1024)}MB`);\n    }\n\n    // Проверяем лимиты\n    const currentFiles = await this.getFilesByType(type);\n    if (currentFiles.length >= this.limits[type]) {\n      throw new Error(`Storage limit reached. Max ${this.limits[type]} ${type} allowed.`);\n    }\n\n    // Создаем объект файла\n    const fileData = {\n      id: Date.now() + Math.random(),\n      name: file.name,\n      type: type,\n      size: file.size,\n      mimetype: file.type,\n      blob: file,\n      url: URL.createObjectURL(file),\n      createdAt: new Date().toISOString(),\n      expiresAt: new Date(Date.now() + this.limits.retentionDays * 24 * 60 * 60 * 1000).toISOString()\n    };\n\n    // Добавляем метаданные для видео/изображений\n    try {\n      if (type === 'videos') {\n        fileData.duration = await this.getVideoDuration(file);\n      } else if (type === 'images') {\n        const dimensions = await this.getImageDimensions(file);\n        fileData.width = dimensions.width;\n        fileData.height = dimensions.height;\n      }\n    } catch (metaError) {\n      console.warn('Failed to get file metadata:', metaError);\n    }\n\n    // Сохраняем в зависимости от режима\n    if (this.fallbackMode) {\n      return this.saveToFallback(fileData);\n    } else {\n      return this.saveToIndexedDB(fileData);\n    }\n  }\n\n  // Сохранение в IndexedDB\n  async saveToIndexedDB(fileData) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction(['files'], 'readwrite');\n        const store = transaction.objectStore('files');\n        const request = store.add(fileData);\n        request.onsuccess = () => {\n          this.updateStorageInfo();\n          resolve(fileData);\n        };\n        request.onerror = () => {\n          var _request$error2;\n          console.error('IndexedDB save error:', request.error);\n          reject(new Error(`Failed to save to IndexedDB: ${((_request$error2 = request.error) === null || _request$error2 === void 0 ? void 0 : _request$error2.message) || 'Unknown error'}`));\n        };\n      } catch (error) {\n        console.error('IndexedDB transaction error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Сохранение в fallback режиме (только в памяти)\n  async saveToFallback(fileData) {\n    try {\n      // Сохраняем в memory storage\n      this.memoryStorage.set(fileData.id.toString(), fileData);\n\n      // В fallback режиме не сохраняем в localStorage, \n      // так как blob объекты не сериализуются\n      console.log(`Saved file ${fileData.name} to memory storage (fallback mode)`);\n      this.updateStorageInfo();\n      return fileData;\n    } catch (error) {\n      console.error('Fallback save error:', error);\n      throw error;\n    }\n  }\n\n  // Получить все файлы определенного типа\n  async getFilesByType(type) {\n    if (this.fallbackMode) {\n      return this.getFromFallback(type);\n    } else {\n      return this.getFromIndexedDB(type);\n    }\n  }\n\n  // Получение из IndexedDB\n  async getFromIndexedDB(type) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction(['files'], 'readonly');\n        const store = transaction.objectStore('files');\n        const index = store.index('type');\n        const request = index.getAll(type);\n        request.onsuccess = () => {\n          const now = new Date();\n          const validFiles = request.result.filter(file => {\n            return new Date(file.expiresAt) > now;\n          });\n          resolve(validFiles);\n        };\n        request.onerror = () => {\n          var _request$error3;\n          console.error('IndexedDB get error:', request.error);\n          reject(new Error(`Failed to get from IndexedDB: ${((_request$error3 = request.error) === null || _request$error3 === void 0 ? void 0 : _request$error3.message) || 'Unknown error'}`));\n        };\n      } catch (error) {\n        console.error('IndexedDB get transaction error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Получение из fallback режима\n  async getFromFallback(type) {\n    const now = new Date();\n    const files = [];\n    for (const [key, file] of this.memoryStorage.entries()) {\n      if (file.type === type && new Date(file.expiresAt) > now) {\n        files.push(file);\n      }\n    }\n    return files;\n  }\n\n  // Получить все файлы\n  async getAllFiles() {\n    try {\n      const videos = await this.getFilesByType('videos');\n      const images = await this.getFilesByType('images');\n      const audios = await this.getFilesByType('audios');\n      return {\n        videos,\n        images,\n        audios\n      };\n    } catch (error) {\n      console.error('Get all files error:', error);\n      return {\n        videos: [],\n        images: [],\n        audios: []\n      };\n    }\n  }\n\n  // Удалить файл\n  async deleteFile(id) {\n    if (this.fallbackMode) {\n      return this.deleteFromFallback(id);\n    } else {\n      return this.deleteFromIndexedDB(id);\n    }\n  }\n\n  // Удаление из IndexedDB\n  async deleteFromIndexedDB(id) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction(['files'], 'readwrite');\n        const store = transaction.objectStore('files');\n        const request = store.delete(id);\n        request.onsuccess = () => {\n          this.updateStorageInfo();\n          resolve();\n        };\n        request.onerror = () => {\n          var _request$error4;\n          console.error('IndexedDB delete error:', request.error);\n          reject(new Error(`Failed to delete from IndexedDB: ${((_request$error4 = request.error) === null || _request$error4 === void 0 ? void 0 : _request$error4.message) || 'Unknown error'}`));\n        };\n      } catch (error) {\n        console.error('IndexedDB delete transaction error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Удаление из fallback режима\n  async deleteFromFallback(id) {\n    try {\n      const file = this.memoryStorage.get(id.toString());\n      if (file && file.url) {\n        URL.revokeObjectURL(file.url);\n      }\n      this.memoryStorage.delete(id.toString());\n      this.updateStorageInfo();\n      return true;\n    } catch (error) {\n      console.error('Fallback delete error:', error);\n      throw error;\n    }\n  }\n\n  // Очистка истекших файлов\n  async cleanupExpiredFiles() {\n    try {\n      const now = new Date();\n      let expiredCount = 0;\n      if (this.fallbackMode) {\n        const keysToDelete = [];\n        for (const [key, file] of this.memoryStorage.entries()) {\n          if (new Date(file.expiresAt) <= now) {\n            keysToDelete.push(key);\n            if (file.url) {\n              URL.revokeObjectURL(file.url);\n            }\n          }\n        }\n        keysToDelete.forEach(key => this.memoryStorage.delete(key));\n        expiredCount = keysToDelete.length;\n      } else {\n        const allFiles = await new Promise(resolve => {\n          const transaction = this.db.transaction(['files'], 'readonly');\n          const store = transaction.objectStore('files');\n          const request = store.getAll();\n          request.onsuccess = () => resolve(request.result || []);\n          request.onerror = () => resolve([]);\n        });\n        const expiredFiles = allFiles.filter(file => {\n          return new Date(file.expiresAt) <= now;\n        });\n        for (const file of expiredFiles) {\n          try {\n            await this.deleteFromIndexedDB(file.id);\n            if (file.url) {\n              URL.revokeObjectURL(file.url);\n            }\n            expiredCount++;\n          } catch (deleteError) {\n            console.warn('Failed to delete expired file:', deleteError);\n          }\n        }\n      }\n      console.log(`Cleaned up ${expiredCount} expired files`);\n      return expiredCount;\n    } catch (error) {\n      console.error('Cleanup error:', error);\n      return 0;\n    }\n  }\n\n  // Получить информацию о хранилище\n  async getStorageInfo() {\n    try {\n      const files = await this.getAllFiles();\n      const totalSize = [...files.videos, ...files.images, ...files.audios].reduce((sum, file) => sum + file.size, 0);\n      return {\n        usage: {\n          videos: files.videos.length,\n          images: files.images.length,\n          audios: files.audios.length,\n          totalSize: totalSize,\n          totalSizeMB: Math.round(totalSize / (1024 * 1024))\n        },\n        limits: this.limits,\n        files: files,\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\n      };\n    } catch (error) {\n      console.error('Get storage info error:', error);\n      return {\n        usage: {\n          videos: 0,\n          images: 0,\n          audios: 0,\n          totalSize: 0,\n          totalSizeMB: 0\n        },\n        limits: this.limits,\n        files: {\n          videos: [],\n          images: [],\n          audios: []\n        },\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\n      };\n    }\n  }\n\n  // Обновить информацию\n  async updateStorageInfo() {\n    try {\n      const info = await this.getStorageInfo();\n\n      // Отправляем событие для обновления UI\n      window.dispatchEvent(new CustomEvent('storageUpdated', {\n        detail: info\n      }));\n    } catch (error) {\n      console.error('Update storage info error:', error);\n    }\n  }\n\n  // Получить длительность видео\n  async getVideoDuration(file) {\n    return new Promise(resolve => {\n      try {\n        const video = document.createElement('video');\n        video.preload = 'metadata';\n        const timeout = setTimeout(() => {\n          video.src = '';\n          resolve(10);\n        }, 5000);\n        video.onloadedmetadata = () => {\n          clearTimeout(timeout);\n          URL.revokeObjectURL(video.src);\n          resolve(video.duration || 10);\n        };\n        video.onerror = () => {\n          clearTimeout(timeout);\n          resolve(10);\n        };\n        video.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn('Video duration error:', error);\n        resolve(10);\n      }\n    });\n  }\n\n  // Получить размеры изображения\n  async getImageDimensions(file) {\n    return new Promise(resolve => {\n      try {\n        const img = new Image();\n        const timeout = setTimeout(() => {\n          img.src = '';\n          resolve({\n            width: 0,\n            height: 0\n          });\n        }, 5000);\n        img.onload = () => {\n          clearTimeout(timeout);\n          URL.revokeObjectURL(img.src);\n          resolve({\n            width: img.width,\n            height: img.height\n          });\n        };\n        img.onerror = () => {\n          clearTimeout(timeout);\n          resolve({\n            width: 0,\n            height: 0\n          });\n        };\n        img.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn('Image dimensions error:', error);\n        resolve({\n          width: 0,\n          height: 0\n        });\n      }\n    });\n  }\n\n  // Проверить, можно ли загрузить файл\n  async canUpload(type) {\n    try {\n      const files = await this.getFilesByType(type);\n      return files.length < this.limits[type];\n    } catch (error) {\n      console.error('Can upload check error:', error);\n      return false;\n    }\n  }\n\n  // Получить оставшееся место\n  async getRemainingSpace(type) {\n    try {\n      const files = await this.getFilesByType(type);\n      return this.limits[type] - files.length;\n    } catch (error) {\n      console.error('Get remaining space error:', error);\n      return 0;\n    }\n  }\n}\nexport default new MediaStorage();","map":{"version":3,"names":["MediaStorage","constructor","dbName","version","db","fallbackMode","memoryStorage","Map","limits","videos","images","audios","maxFileSize","retentionDays","isIndexedDBSupported","window","indexedDB","init","console","warn","initFallback","initIndexedDB","error","Promise","resolve","reject","request","open","onerror","_request$error","Error","message","onsuccess","result","log","onupgradeneeded","event","target","objectStoreNames","contains","fileStore","createObjectStore","keyPath","createIndex","upgradeError","onblocked","clear","localStorage","removeItem","saveFile","file","type","size","currentFiles","getFilesByType","length","fileData","id","Date","now","Math","random","name","mimetype","blob","url","URL","createObjectURL","createdAt","toISOString","expiresAt","duration","getVideoDuration","dimensions","getImageDimensions","width","height","metaError","saveToFallback","saveToIndexedDB","transaction","store","objectStore","add","updateStorageInfo","_request$error2","set","toString","getFromFallback","getFromIndexedDB","index","getAll","validFiles","filter","_request$error3","files","key","entries","push","getAllFiles","deleteFile","deleteFromFallback","deleteFromIndexedDB","delete","_request$error4","get","revokeObjectURL","cleanupExpiredFiles","expiredCount","keysToDelete","forEach","allFiles","expiredFiles","deleteError","getStorageInfo","totalSize","reduce","sum","usage","totalSizeMB","round","mode","info","dispatchEvent","CustomEvent","detail","video","document","createElement","preload","timeout","setTimeout","src","onloadedmetadata","clearTimeout","img","Image","onload","canUpload","getRemainingSpace"],"sources":["C:/Scriptify/ai-content-studio/frontend/src/components/utils/MediaStorage.js"],"sourcesContent":["// MediaStorage.js - Умное локальное хранилище для MVP\r\nclass MediaStorage {\r\n  constructor() {\r\n    this.dbName = 'VideoEditorDB';\r\n    this.version = 1;\r\n    this.db = null;\r\n    this.fallbackMode = false;\r\n    this.memoryStorage = new Map();\r\n    this.limits = {\r\n      videos: 5,\r\n      images: 10,\r\n      audios: 5,\r\n      maxFileSize: 100 * 1024 * 1024, // 100MB\r\n      retentionDays: 7\r\n    };\r\n  }\r\n\r\n  // Проверка поддержки IndexedDB\r\n  isIndexedDBSupported() {\r\n    return 'indexedDB' in window && indexedDB !== null;\r\n  }\r\n\r\n  // Инициализация IndexedDB или fallback\r\n  async init() {\r\n    if (!this.isIndexedDBSupported()) {\r\n      console.warn('IndexedDB not supported, using fallback mode');\r\n      this.fallbackMode = true;\r\n      return this.initFallback();\r\n    }\r\n\r\n    try {\r\n      return await this.initIndexedDB();\r\n    } catch (error) {\r\n      console.warn('IndexedDB initialization failed, switching to fallback mode:', error);\r\n      this.fallbackMode = true;\r\n      return this.initFallback();\r\n    }\r\n  }\r\n\r\n  // Инициализация IndexedDB\r\n  async initIndexedDB() {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const request = indexedDB.open(this.dbName, this.version);\r\n\r\n        request.onerror = () => {\r\n          console.error('IndexedDB error:', request.error);\r\n          reject(new Error(`IndexedDB error: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n          this.db = request.result;\r\n          console.log('IndexedDB initialized successfully');\r\n          resolve(this.db);\r\n        };\r\n\r\n        request.onupgradeneeded = (event) => {\r\n          try {\r\n            const db = event.target.result;\r\n\r\n            if (!db.objectStoreNames.contains('files')) {\r\n              const fileStore = db.createObjectStore('files', { keyPath: 'id' });\r\n              fileStore.createIndex('type', 'type');\r\n              fileStore.createIndex('createdAt', 'createdAt');\r\n              console.log('IndexedDB store created');\r\n            }\r\n          } catch (upgradeError) {\r\n            console.error('IndexedDB upgrade error:', upgradeError);\r\n            reject(upgradeError);\r\n          }\r\n        };\r\n\r\n        request.onblocked = () => {\r\n          console.warn('IndexedDB blocked - another tab may be open');\r\n          reject(new Error('IndexedDB blocked by another tab'));\r\n        };\r\n\r\n      } catch (error) {\r\n        console.error('IndexedDB initialization error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Инициализация fallback режима\r\n  async initFallback() {\r\n    console.log('Initializing fallback storage mode');\r\n    this.fallbackMode = true;\r\n    \r\n    // В fallback режиме мы не можем восстановить blob объекты из localStorage\r\n    // Поэтому просто очищаем память\r\n    this.memoryStorage.clear();\r\n    \r\n    // Очищаем старые метаданные из localStorage для избежания путаницы\r\n    try {\r\n      localStorage.removeItem('mediaFiles');\r\n      console.log('Cleared old localStorage data for fresh start');\r\n    } catch (error) {\r\n      console.warn('Failed to clear localStorage:', error);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // Сохранить файл\r\n  async saveFile(file, type) {\r\n    // Проверяем размер файла\r\n    if (file.size > this.limits.maxFileSize) {\r\n      throw new Error(`File too large. Max size: ${this.limits.maxFileSize / (1024 * 1024)}MB`);\r\n    }\r\n\r\n    // Проверяем лимиты\r\n    const currentFiles = await this.getFilesByType(type);\r\n    if (currentFiles.length >= this.limits[type]) {\r\n      throw new Error(`Storage limit reached. Max ${this.limits[type]} ${type} allowed.`);\r\n    }\r\n\r\n    // Создаем объект файла\r\n    const fileData = {\r\n      id: Date.now() + Math.random(),\r\n      name: file.name,\r\n      type: type,\r\n      size: file.size,\r\n      mimetype: file.type,\r\n      blob: file,\r\n      url: URL.createObjectURL(file),\r\n      createdAt: new Date().toISOString(),\r\n      expiresAt: new Date(Date.now() + this.limits.retentionDays * 24 * 60 * 60 * 1000).toISOString()\r\n    };\r\n\r\n    // Добавляем метаданные для видео/изображений\r\n    try {\r\n      if (type === 'videos') {\r\n        fileData.duration = await this.getVideoDuration(file);\r\n      } else if (type === 'images') {\r\n        const dimensions = await this.getImageDimensions(file);\r\n        fileData.width = dimensions.width;\r\n        fileData.height = dimensions.height;\r\n      }\r\n    } catch (metaError) {\r\n      console.warn('Failed to get file metadata:', metaError);\r\n    }\r\n\r\n    // Сохраняем в зависимости от режима\r\n    if (this.fallbackMode) {\r\n      return this.saveToFallback(fileData);\r\n    } else {\r\n      return this.saveToIndexedDB(fileData);\r\n    }\r\n  }\r\n\r\n  // Сохранение в IndexedDB\r\n  async saveToIndexedDB(fileData) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction(['files'], 'readwrite');\r\n        const store = transaction.objectStore('files');\r\n        const request = store.add(fileData);\r\n\r\n        request.onsuccess = () => {\r\n          this.updateStorageInfo();\r\n          resolve(fileData);\r\n        };\r\n        \r\n        request.onerror = () => {\r\n          console.error('IndexedDB save error:', request.error);\r\n          reject(new Error(`Failed to save to IndexedDB: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n      } catch (error) {\r\n        console.error('IndexedDB transaction error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Сохранение в fallback режиме (только в памяти)\r\n  async saveToFallback(fileData) {\r\n    try {\r\n      // Сохраняем в memory storage\r\n      this.memoryStorage.set(fileData.id.toString(), fileData);\r\n      \r\n      // В fallback режиме не сохраняем в localStorage, \r\n      // так как blob объекты не сериализуются\r\n      console.log(`Saved file ${fileData.name} to memory storage (fallback mode)`);\r\n\r\n      this.updateStorageInfo();\r\n      return fileData;\r\n    } catch (error) {\r\n      console.error('Fallback save error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Получить все файлы определенного типа\r\n  async getFilesByType(type) {\r\n    if (this.fallbackMode) {\r\n      return this.getFromFallback(type);\r\n    } else {\r\n      return this.getFromIndexedDB(type);\r\n    }\r\n  }\r\n\r\n  // Получение из IndexedDB\r\n  async getFromIndexedDB(type) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction(['files'], 'readonly');\r\n        const store = transaction.objectStore('files');\r\n        const index = store.index('type');\r\n        const request = index.getAll(type);\r\n\r\n        request.onsuccess = () => {\r\n          const now = new Date();\r\n          const validFiles = request.result.filter(file => {\r\n            return new Date(file.expiresAt) > now;\r\n          });\r\n          resolve(validFiles);\r\n        };\r\n        \r\n        request.onerror = () => {\r\n          console.error('IndexedDB get error:', request.error);\r\n          reject(new Error(`Failed to get from IndexedDB: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n      } catch (error) {\r\n        console.error('IndexedDB get transaction error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Получение из fallback режима\r\n  async getFromFallback(type) {\r\n    const now = new Date();\r\n    const files = [];\r\n    \r\n    for (const [key, file] of this.memoryStorage.entries()) {\r\n      if (file.type === type && new Date(file.expiresAt) > now) {\r\n        files.push(file);\r\n      }\r\n    }\r\n    \r\n    return files;\r\n  }\r\n\r\n  // Получить все файлы\r\n  async getAllFiles() {\r\n    try {\r\n      const videos = await this.getFilesByType('videos');\r\n      const images = await this.getFilesByType('images');\r\n      const audios = await this.getFilesByType('audios');\r\n      \r\n      return { videos, images, audios };\r\n    } catch (error) {\r\n      console.error('Get all files error:', error);\r\n      return { videos: [], images: [], audios: [] };\r\n    }\r\n  }\r\n\r\n  // Удалить файл\r\n  async deleteFile(id) {\r\n    if (this.fallbackMode) {\r\n      return this.deleteFromFallback(id);\r\n    } else {\r\n      return this.deleteFromIndexedDB(id);\r\n    }\r\n  }\r\n\r\n  // Удаление из IndexedDB\r\n  async deleteFromIndexedDB(id) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction(['files'], 'readwrite');\r\n        const store = transaction.objectStore('files');\r\n        const request = store.delete(id);\r\n\r\n        request.onsuccess = () => {\r\n          this.updateStorageInfo();\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = () => {\r\n          console.error('IndexedDB delete error:', request.error);\r\n          reject(new Error(`Failed to delete from IndexedDB: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n      } catch (error) {\r\n        console.error('IndexedDB delete transaction error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Удаление из fallback режима\r\n  async deleteFromFallback(id) {\r\n    try {\r\n      const file = this.memoryStorage.get(id.toString());\r\n      if (file && file.url) {\r\n        URL.revokeObjectURL(file.url);\r\n      }\r\n      \r\n      this.memoryStorage.delete(id.toString());\r\n      this.updateStorageInfo();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Fallback delete error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Очистка истекших файлов\r\n  async cleanupExpiredFiles() {\r\n    try {\r\n      const now = new Date();\r\n      let expiredCount = 0;\r\n\r\n      if (this.fallbackMode) {\r\n        const keysToDelete = [];\r\n        for (const [key, file] of this.memoryStorage.entries()) {\r\n          if (new Date(file.expiresAt) <= now) {\r\n            keysToDelete.push(key);\r\n            if (file.url) {\r\n              URL.revokeObjectURL(file.url);\r\n            }\r\n          }\r\n        }\r\n        \r\n        keysToDelete.forEach(key => this.memoryStorage.delete(key));\r\n        expiredCount = keysToDelete.length;\r\n      } else {\r\n        const allFiles = await new Promise((resolve) => {\r\n          const transaction = this.db.transaction(['files'], 'readonly');\r\n          const store = transaction.objectStore('files');\r\n          const request = store.getAll();\r\n          \r\n          request.onsuccess = () => resolve(request.result || []);\r\n          request.onerror = () => resolve([]);\r\n        });\r\n\r\n        const expiredFiles = allFiles.filter(file => {\r\n          return new Date(file.expiresAt) <= now;\r\n        });\r\n\r\n        for (const file of expiredFiles) {\r\n          try {\r\n            await this.deleteFromIndexedDB(file.id);\r\n            if (file.url) {\r\n              URL.revokeObjectURL(file.url);\r\n            }\r\n            expiredCount++;\r\n          } catch (deleteError) {\r\n            console.warn('Failed to delete expired file:', deleteError);\r\n          }\r\n        }\r\n      }\r\n\r\n      console.log(`Cleaned up ${expiredCount} expired files`);\r\n      return expiredCount;\r\n    } catch (error) {\r\n      console.error('Cleanup error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Получить информацию о хранилище\r\n  async getStorageInfo() {\r\n    try {\r\n      const files = await this.getAllFiles();\r\n      const totalSize = [...files.videos, ...files.images, ...files.audios]\r\n        .reduce((sum, file) => sum + file.size, 0);\r\n\r\n      return {\r\n        usage: {\r\n          videos: files.videos.length,\r\n          images: files.images.length,\r\n          audios: files.audios.length,\r\n          totalSize: totalSize,\r\n          totalSizeMB: Math.round(totalSize / (1024 * 1024))\r\n        },\r\n        limits: this.limits,\r\n        files: files,\r\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\r\n      };\r\n    } catch (error) {\r\n      console.error('Get storage info error:', error);\r\n      return {\r\n        usage: { videos: 0, images: 0, audios: 0, totalSize: 0, totalSizeMB: 0 },\r\n        limits: this.limits,\r\n        files: { videos: [], images: [], audios: [] },\r\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Обновить информацию\r\n  async updateStorageInfo() {\r\n    try {\r\n      const info = await this.getStorageInfo();\r\n      \r\n      // Отправляем событие для обновления UI\r\n      window.dispatchEvent(new CustomEvent('storageUpdated', { detail: info }));\r\n    } catch (error) {\r\n      console.error('Update storage info error:', error);\r\n    }\r\n  }\r\n\r\n  // Получить длительность видео\r\n  async getVideoDuration(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const video = document.createElement('video');\r\n        video.preload = 'metadata';\r\n        \r\n        const timeout = setTimeout(() => {\r\n          video.src = '';\r\n          resolve(10);\r\n        }, 5000);\r\n        \r\n        video.onloadedmetadata = () => {\r\n          clearTimeout(timeout);\r\n          URL.revokeObjectURL(video.src);\r\n          resolve(video.duration || 10);\r\n        };\r\n        \r\n        video.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve(10);\r\n        };\r\n        \r\n        video.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn('Video duration error:', error);\r\n        resolve(10);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Получить размеры изображения\r\n  async getImageDimensions(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const img = new Image();\r\n        \r\n        const timeout = setTimeout(() => {\r\n          img.src = '';\r\n          resolve({ width: 0, height: 0 });\r\n        }, 5000);\r\n        \r\n        img.onload = () => {\r\n          clearTimeout(timeout);\r\n          URL.revokeObjectURL(img.src);\r\n          resolve({ width: img.width, height: img.height });\r\n        };\r\n        \r\n        img.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve({ width: 0, height: 0 });\r\n        };\r\n        \r\n        img.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn('Image dimensions error:', error);\r\n        resolve({ width: 0, height: 0 });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Проверить, можно ли загрузить файл\r\n  async canUpload(type) {\r\n    try {\r\n      const files = await this.getFilesByType(type);\r\n      return files.length < this.limits[type];\r\n    } catch (error) {\r\n      console.error('Can upload check error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Получить оставшееся место\r\n  async getRemainingSpace(type) {\r\n    try {\r\n      const files = await this.getFilesByType(type);\r\n      return this.limits[type] - files.length;\r\n    } catch (error) {\r\n      console.error('Get remaining space error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new MediaStorage();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}