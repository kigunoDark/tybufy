{"ast":null,"code":"class MediaStorage {\n  constructor() {\n    this.dbName = \"VideoEditorDB\";\n    this.version = 1;\n    this.db = null;\n    this.fallbackMode = false;\n    this.memoryStorage = new Map();\n    this.limits = {\n      videos: 5,\n      images: 10,\n      audios: 5,\n      maxFileSize: 100 * 1024 * 1024,\n      // 100MB\n      retentionDays: 7\n    };\n  }\n  isIndexedDBSupported() {\n    return \"indexedDB\" in window && indexedDB !== null;\n  }\n  async init() {\n    if (!this.isIndexedDBSupported()) {\n      console.warn(\"IndexedDB not supported, using fallback mode\");\n      this.fallbackMode = true;\n      return this.initFallback();\n    }\n    try {\n      return await this.initIndexedDB();\n    } catch (error) {\n      console.warn(\"IndexedDB initialization failed, switching to fallback mode:\", error);\n      this.fallbackMode = true;\n      return this.initFallback();\n    }\n  }\n  async initIndexedDB() {\n    return new Promise((resolve, reject) => {\n      try {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          var _request$error;\n          console.error(\"IndexedDB error:\", request.error);\n          reject(new Error(`IndexedDB error: ${((_request$error = request.error) === null || _request$error === void 0 ? void 0 : _request$error.message) || \"Unknown error\"}`));\n        };\n        request.onsuccess = () => {\n          this.db = request.result;\n          console.log(\"IndexedDB initialized successfully\");\n          resolve(this.db);\n        };\n        request.onupgradeneeded = event => {\n          try {\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains(\"files\")) {\n              const fileStore = db.createObjectStore(\"files\", {\n                keyPath: \"id\"\n              });\n              fileStore.createIndex(\"type\", \"type\");\n              fileStore.createIndex(\"mediaType\", \"mediaType\"); // ✅ Добавляем индекс для mediaType\n              fileStore.createIndex(\"createdAt\", \"createdAt\");\n              console.log(\"IndexedDB store created\");\n            }\n          } catch (upgradeError) {\n            console.error(\"IndexedDB upgrade error:\", upgradeError);\n            reject(upgradeError);\n          }\n        };\n        request.onblocked = () => {\n          console.warn(\"IndexedDB blocked - another tab may be open\");\n          reject(new Error(\"IndexedDB blocked by another tab\"));\n        };\n      } catch (error) {\n        console.error(\"IndexedDB initialization error:\", error);\n        reject(error);\n      }\n    });\n  }\n  async initFallback() {\n    console.log(\"Initializing fallback storage mode\");\n    this.fallbackMode = true;\n    this.memoryStorage.clear();\n    try {\n      localStorage.removeItem(\"mediaFiles\");\n      console.log(\"Cleared old localStorage data for fresh start\");\n    } catch (error) {\n      console.warn(\"Failed to clear localStorage:\", error);\n    }\n    return true;\n  }\n\n  // ✅ Проверка размера файла перед сохранением\n  checkFileSize(file) {\n    if (file.size > this.limits.maxFileSize) {\n      const sizeMB = (file.size / (1024 * 1024)).toFixed(2);\n      const limitMB = (this.limits.maxFileSize / (1024 * 1024)).toFixed(0);\n      throw new Error(`File too large. File size: ${sizeMB}MB, Max size: ${limitMB}MB`);\n    }\n  }\n  async saveFile(file, type) {\n    // ✅ Проверяем размер файла перед обработкой\n    this.checkFileSize(file);\n    const currentFiles = await this.getFilesByType(type);\n    if (currentFiles.length >= this.limits[type]) {\n      throw new Error(`Storage limit reached. Max ${this.limits[type]} ${type} allowed.`);\n    }\n    const fileData = {\n      id: Date.now() + Math.random(),\n      name: file.name,\n      type: type,\n      // Оригинальный тип для совместимости\n      mediaType: type,\n      // ✅ Добавляем mediaType для правильной категоризации\n      size: file.size,\n      mimetype: file.type,\n      blob: file,\n      url: URL.createObjectURL(file),\n      createdAt: new Date().toISOString(),\n      expiresAt: new Date(Date.now() + this.limits.retentionDays * 24 * 60 * 60 * 1000).toISOString()\n    };\n    try {\n      if (type === \"videos\") {\n        fileData.duration = await this.getVideoDuration(file);\n      } else if (type === \"audios\") {\n        fileData.duration = await this.getAudioDuration(file);\n      } else if (type === \"images\") {\n        const dimensions = await this.getImageDimensions(file);\n        fileData.width = dimensions.width;\n        fileData.height = dimensions.height;\n      }\n    } catch (metaError) {\n      console.warn(\"Failed to get file metadata:\", metaError);\n    }\n    if (this.fallbackMode) {\n      return this.saveToFallback(fileData);\n    } else {\n      return this.saveToIndexedDB(fileData);\n    }\n  }\n  async saveToIndexedDB(fileData) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction([\"files\"], \"readwrite\");\n        const store = transaction.objectStore(\"files\");\n        const request = store.add(fileData);\n        request.onsuccess = () => {\n          this.updateStorageInfo();\n          resolve(fileData);\n        };\n        request.onerror = () => {\n          var _request$error2;\n          console.error(\"IndexedDB save error:\", request.error);\n          reject(new Error(`Failed to save to IndexedDB: ${((_request$error2 = request.error) === null || _request$error2 === void 0 ? void 0 : _request$error2.message) || \"Unknown error\"}`));\n        };\n      } catch (error) {\n        console.error(\"IndexedDB transaction error:\", error);\n        reject(error);\n      }\n    });\n  }\n  async saveToFallback(fileData) {\n    try {\n      this.memoryStorage.set(fileData.id.toString(), fileData);\n      console.log(`Saved file ${fileData.name} to memory storage (fallback mode)`);\n      this.updateStorageInfo();\n      return fileData;\n    } catch (error) {\n      console.error(\"Fallback save error:\", error);\n      throw error;\n    }\n  }\n  async getFilesByType(type) {\n    if (this.fallbackMode) {\n      return this.getFromFallback(type);\n    } else {\n      return this.getFromIndexedDB(type);\n    }\n  }\n  async getFromIndexedDB(type) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction([\"files\"], \"readonly\");\n        const store = transaction.objectStore(\"files\");\n\n        // ✅ Используем mediaType индекс если он существует, иначе type\n        let index;\n        try {\n          index = store.index(\"mediaType\");\n        } catch (e) {\n          index = store.index(\"type\");\n        }\n        const request = index.getAll(type);\n        request.onsuccess = () => {\n          const now = new Date();\n          const validFiles = request.result.filter(file => {\n            return new Date(file.expiresAt) > now;\n          });\n          resolve(validFiles);\n        };\n        request.onerror = () => {\n          var _request$error3;\n          console.error(\"IndexedDB get error:\", request.error);\n          reject(new Error(`Failed to get from IndexedDB: ${((_request$error3 = request.error) === null || _request$error3 === void 0 ? void 0 : _request$error3.message) || \"Unknown error\"}`));\n        };\n      } catch (error) {\n        console.error(\"IndexedDB get transaction error:\", error);\n        reject(error);\n      }\n    });\n  }\n  async getFromFallback(type) {\n    const now = new Date();\n    const files = [];\n    for (const [key, file] of this.memoryStorage.entries()) {\n      // ✅ Проверяем как mediaType, так и type для совместимости\n      const fileType = file.mediaType || file.type;\n      if (fileType === type && new Date(file.expiresAt) > now) {\n        files.push(file);\n      }\n    }\n    return files;\n  }\n  async getAllFiles() {\n    try {\n      const videos = await this.getFilesByType(\"videos\");\n      const images = await this.getFilesByType(\"images\");\n      const audios = await this.getFilesByType(\"audios\");\n      return {\n        videos,\n        images,\n        audios\n      };\n    } catch (error) {\n      console.error(\"Get all files error:\", error);\n      return {\n        videos: [],\n        images: [],\n        audios: []\n      };\n    }\n  }\n  async deleteFile(id) {\n    if (this.fallbackMode) {\n      return this.deleteFromFallback(id);\n    } else {\n      return this.deleteFromIndexedDB(id);\n    }\n  }\n  async deleteFromIndexedDB(id) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction([\"files\"], \"readwrite\");\n        const store = transaction.objectStore(\"files\");\n        const request = store.delete(id);\n        request.onsuccess = () => {\n          this.updateStorageInfo();\n          resolve();\n        };\n        request.onerror = () => {\n          var _request$error4;\n          console.error(\"IndexedDB delete error:\", request.error);\n          reject(new Error(`Failed to delete from IndexedDB: ${((_request$error4 = request.error) === null || _request$error4 === void 0 ? void 0 : _request$error4.message) || \"Unknown error\"}`));\n        };\n      } catch (error) {\n        console.error(\"IndexedDB delete transaction error:\", error);\n        reject(error);\n      }\n    });\n  }\n  async deleteFromFallback(id) {\n    try {\n      const file = this.memoryStorage.get(id.toString());\n      if (file && file.url) {\n        URL.revokeObjectURL(file.url);\n      }\n      this.memoryStorage.delete(id.toString());\n      this.updateStorageInfo();\n      return true;\n    } catch (error) {\n      console.error(\"Fallback delete error:\", error);\n      throw error;\n    }\n  }\n  async cleanupExpiredFiles() {\n    try {\n      const now = new Date();\n      let expiredCount = 0;\n      if (this.fallbackMode) {\n        const keysToDelete = [];\n        for (const [key, file] of this.memoryStorage.entries()) {\n          if (new Date(file.expiresAt) <= now) {\n            keysToDelete.push(key);\n            if (file.url) {\n              URL.revokeObjectURL(file.url);\n            }\n          }\n        }\n        keysToDelete.forEach(key => this.memoryStorage.delete(key));\n        expiredCount = keysToDelete.length;\n      } else {\n        const allFiles = await new Promise(resolve => {\n          const transaction = this.db.transaction([\"files\"], \"readonly\");\n          const store = transaction.objectStore(\"files\");\n          const request = store.getAll();\n          request.onsuccess = () => resolve(request.result || []);\n          request.onerror = () => resolve([]);\n        });\n        const expiredFiles = allFiles.filter(file => {\n          return new Date(file.expiresAt) <= now;\n        });\n        for (const file of expiredFiles) {\n          try {\n            await this.deleteFromIndexedDB(file.id);\n            if (file.url) {\n              URL.revokeObjectURL(file.url);\n            }\n            expiredCount++;\n          } catch (deleteError) {\n            console.warn(\"Failed to delete expired file:\", deleteError);\n          }\n        }\n      }\n      console.log(`Cleaned up ${expiredCount} expired files`);\n      return expiredCount;\n    } catch (error) {\n      console.error(\"Cleanup error:\", error);\n      return 0;\n    }\n  }\n  async getStorageInfo() {\n    try {\n      const files = await this.getAllFiles();\n      const totalSize = [...files.videos, ...files.images, ...files.audios].reduce((sum, file) => sum + file.size, 0);\n      return {\n        usage: {\n          videos: files.videos.length,\n          images: files.images.length,\n          audios: files.audios.length,\n          totalSize: totalSize,\n          totalSizeMB: Math.round(totalSize / (1024 * 1024))\n        },\n        limits: this.limits,\n        files: files,\n        mode: this.fallbackMode ? \"fallback\" : \"indexeddb\"\n      };\n    } catch (error) {\n      console.error(\"Get storage info error:\", error);\n      return {\n        usage: {\n          videos: 0,\n          images: 0,\n          audios: 0,\n          totalSize: 0,\n          totalSizeMB: 0\n        },\n        limits: this.limits,\n        files: {\n          videos: [],\n          images: [],\n          audios: []\n        },\n        mode: this.fallbackMode ? \"fallback\" : \"indexeddb\"\n      };\n    }\n  }\n  async updateStorageInfo() {\n    try {\n      const info = await this.getStorageInfo();\n      window.dispatchEvent(new CustomEvent(\"storageUpdated\", {\n        detail: info\n      }));\n    } catch (error) {\n      console.error(\"Update storage info error:\", error);\n    }\n  }\n  async getVideoDuration(file) {\n    return new Promise(resolve => {\n      try {\n        const video = document.createElement(\"video\");\n        video.preload = \"metadata\";\n        const timeout = setTimeout(() => {\n          video.src = \"\";\n          resolve(10);\n        }, 5000);\n        video.onloadedmetadata = () => {\n          clearTimeout(timeout);\n          URL.revokeObjectURL(video.src);\n          resolve(video.duration || 10);\n        };\n        video.onerror = () => {\n          clearTimeout(timeout);\n          resolve(10);\n        };\n        video.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn(\"Video duration error:\", error);\n        resolve(10);\n      }\n    });\n  }\n\n  // ✅ Добавляем метод для получения длительности аудио\n  async getAudioDuration(file) {\n    return new Promise(resolve => {\n      try {\n        const audio = document.createElement(\"audio\");\n        audio.preload = \"metadata\";\n        const timeout = setTimeout(() => {\n          audio.src = \"\";\n          resolve(10);\n        }, 5000);\n        audio.onloadedmetadata = () => {\n          clearTimeout(timeout);\n          URL.revokeObjectURL(audio.src);\n          resolve(audio.duration || 10);\n        };\n        audio.onerror = () => {\n          clearTimeout(timeout);\n          resolve(10);\n        };\n        audio.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn(\"Audio duration error:\", error);\n        resolve(10);\n      }\n    });\n  }\n  async getImageDimensions(file) {\n    return new Promise(resolve => {\n      try {\n        const img = new Image();\n        const timeout = setTimeout(() => {\n          img.src = \"\";\n          resolve({\n            width: 0,\n            height: 0\n          });\n        }, 5000);\n        img.onload = () => {\n          clearTimeout(timeout);\n          URL.revokeObjectURL(img.src);\n          resolve({\n            width: img.width,\n            height: img.height\n          });\n        };\n        img.onerror = () => {\n          clearTimeout(timeout);\n          resolve({\n            width: 0,\n            height: 0\n          });\n        };\n        img.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn(\"Image dimensions error:\", error);\n        resolve({\n          width: 0,\n          height: 0\n        });\n      }\n    });\n  }\n  async canUpload(type) {\n    try {\n      const files = await this.getFilesByType(type);\n      return files.length < this.limits[type];\n    } catch (error) {\n      console.error(\"Can upload check error:\", error);\n      return false;\n    }\n  }\n  async getRemainingSpace(type) {\n    try {\n      const files = await this.getFilesByType(type);\n      return this.limits[type] - files.length;\n    } catch (error) {\n      console.error(\"Get remaining space error:\", error);\n      return 0;\n    }\n  }\n\n  // ✅ Добавляем метод для проверки размера файла\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n}\nexport default new MediaStorage();","map":{"version":3,"names":["MediaStorage","constructor","dbName","version","db","fallbackMode","memoryStorage","Map","limits","videos","images","audios","maxFileSize","retentionDays","isIndexedDBSupported","window","indexedDB","init","console","warn","initFallback","initIndexedDB","error","Promise","resolve","reject","request","open","onerror","_request$error","Error","message","onsuccess","result","log","onupgradeneeded","event","target","objectStoreNames","contains","fileStore","createObjectStore","keyPath","createIndex","upgradeError","onblocked","clear","localStorage","removeItem","checkFileSize","file","size","sizeMB","toFixed","limitMB","saveFile","type","currentFiles","getFilesByType","length","fileData","id","Date","now","Math","random","name","mediaType","mimetype","blob","url","URL","createObjectURL","createdAt","toISOString","expiresAt","duration","getVideoDuration","getAudioDuration","dimensions","getImageDimensions","width","height","metaError","saveToFallback","saveToIndexedDB","transaction","store","objectStore","add","updateStorageInfo","_request$error2","set","toString","getFromFallback","getFromIndexedDB","index","e","getAll","validFiles","filter","_request$error3","files","key","entries","fileType","push","getAllFiles","deleteFile","deleteFromFallback","deleteFromIndexedDB","delete","_request$error4","get","revokeObjectURL","cleanupExpiredFiles","expiredCount","keysToDelete","forEach","allFiles","expiredFiles","deleteError","getStorageInfo","totalSize","reduce","sum","usage","totalSizeMB","round","mode","info","dispatchEvent","CustomEvent","detail","video","document","createElement","preload","timeout","setTimeout","src","onloadedmetadata","clearTimeout","audio","img","Image","onload","canUpload","getRemainingSpace","formatFileSize","bytes","k","sizes","i","floor","parseFloat","pow"],"sources":["C:/Scriptify/ai-content-studio/frontend/src/components/utils/MediaStorage.js"],"sourcesContent":["class MediaStorage {\r\n  constructor() {\r\n    this.dbName = \"VideoEditorDB\";\r\n    this.version = 1;\r\n    this.db = null;\r\n    this.fallbackMode = false;\r\n    this.memoryStorage = new Map();\r\n    this.limits = {\r\n      videos: 5,\r\n      images: 10,\r\n      audios: 5,\r\n      maxFileSize: 100 * 1024 * 1024, // 100MB\r\n      retentionDays: 7,\r\n    };\r\n  }\r\n\r\n  isIndexedDBSupported() {\r\n    return \"indexedDB\" in window && indexedDB !== null;\r\n  }\r\n\r\n  async init() {\r\n    if (!this.isIndexedDBSupported()) {\r\n      console.warn(\"IndexedDB not supported, using fallback mode\");\r\n      this.fallbackMode = true;\r\n      return this.initFallback();\r\n    }\r\n\r\n    try {\r\n      return await this.initIndexedDB();\r\n    } catch (error) {\r\n      console.warn(\r\n        \"IndexedDB initialization failed, switching to fallback mode:\",\r\n        error\r\n      );\r\n      this.fallbackMode = true;\r\n      return this.initFallback();\r\n    }\r\n  }\r\n\r\n  async initIndexedDB() {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const request = indexedDB.open(this.dbName, this.version);\r\n\r\n        request.onerror = () => {\r\n          console.error(\"IndexedDB error:\", request.error);\r\n          reject(\r\n            new Error(\r\n              `IndexedDB error: ${request.error?.message || \"Unknown error\"}`\r\n            )\r\n          );\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n          this.db = request.result;\r\n          console.log(\"IndexedDB initialized successfully\");\r\n          resolve(this.db);\r\n        };\r\n\r\n        request.onupgradeneeded = (event) => {\r\n          try {\r\n            const db = event.target.result;\r\n\r\n            if (!db.objectStoreNames.contains(\"files\")) {\r\n              const fileStore = db.createObjectStore(\"files\", {\r\n                keyPath: \"id\",\r\n              });\r\n              fileStore.createIndex(\"type\", \"type\");\r\n              fileStore.createIndex(\"mediaType\", \"mediaType\"); // ✅ Добавляем индекс для mediaType\r\n              fileStore.createIndex(\"createdAt\", \"createdAt\");\r\n              console.log(\"IndexedDB store created\");\r\n            }\r\n          } catch (upgradeError) {\r\n            console.error(\"IndexedDB upgrade error:\", upgradeError);\r\n            reject(upgradeError);\r\n          }\r\n        };\r\n\r\n        request.onblocked = () => {\r\n          console.warn(\"IndexedDB blocked - another tab may be open\");\r\n          reject(new Error(\"IndexedDB blocked by another tab\"));\r\n        };\r\n      } catch (error) {\r\n        console.error(\"IndexedDB initialization error:\", error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async initFallback() {\r\n    console.log(\"Initializing fallback storage mode\");\r\n    this.fallbackMode = true;\r\n\r\n    this.memoryStorage.clear();\r\n\r\n    try {\r\n      localStorage.removeItem(\"mediaFiles\");\r\n      console.log(\"Cleared old localStorage data for fresh start\");\r\n    } catch (error) {\r\n      console.warn(\"Failed to clear localStorage:\", error);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // ✅ Проверка размера файла перед сохранением\r\n  checkFileSize(file) {\r\n    if (file.size > this.limits.maxFileSize) {\r\n      const sizeMB = (file.size / (1024 * 1024)).toFixed(2);\r\n      const limitMB = (this.limits.maxFileSize / (1024 * 1024)).toFixed(0);\r\n      throw new Error(\r\n        `File too large. File size: ${sizeMB}MB, Max size: ${limitMB}MB`\r\n      );\r\n    }\r\n  }\r\n\r\n  async saveFile(file, type) {\r\n    // ✅ Проверяем размер файла перед обработкой\r\n    this.checkFileSize(file);\r\n\r\n    const currentFiles = await this.getFilesByType(type);\r\n    if (currentFiles.length >= this.limits[type]) {\r\n      throw new Error(\r\n        `Storage limit reached. Max ${this.limits[type]} ${type} allowed.`\r\n      );\r\n    }\r\n\r\n    const fileData = {\r\n      id: Date.now() + Math.random(),\r\n      name: file.name,\r\n      type: type, // Оригинальный тип для совместимости\r\n      mediaType: type, // ✅ Добавляем mediaType для правильной категоризации\r\n      size: file.size,\r\n      mimetype: file.type,\r\n      blob: file,\r\n      url: URL.createObjectURL(file),\r\n      createdAt: new Date().toISOString(),\r\n      expiresAt: new Date(\r\n        Date.now() + this.limits.retentionDays * 24 * 60 * 60 * 1000\r\n      ).toISOString(),\r\n    };\r\n\r\n    try {\r\n      if (type === \"videos\") {\r\n        fileData.duration = await this.getVideoDuration(file);\r\n      } else if (type === \"audios\") {\r\n        fileData.duration = await this.getAudioDuration(file);\r\n      } else if (type === \"images\") {\r\n        const dimensions = await this.getImageDimensions(file);\r\n        fileData.width = dimensions.width;\r\n        fileData.height = dimensions.height;\r\n      }\r\n    } catch (metaError) {\r\n      console.warn(\"Failed to get file metadata:\", metaError);\r\n    }\r\n\r\n    if (this.fallbackMode) {\r\n      return this.saveToFallback(fileData);\r\n    } else {\r\n      return this.saveToIndexedDB(fileData);\r\n    }\r\n  }\r\n\r\n  async saveToIndexedDB(fileData) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction([\"files\"], \"readwrite\");\r\n        const store = transaction.objectStore(\"files\");\r\n        const request = store.add(fileData);\r\n\r\n        request.onsuccess = () => {\r\n          this.updateStorageInfo();\r\n          resolve(fileData);\r\n        };\r\n\r\n        request.onerror = () => {\r\n          console.error(\"IndexedDB save error:\", request.error);\r\n          reject(\r\n            new Error(\r\n              `Failed to save to IndexedDB: ${\r\n                request.error?.message || \"Unknown error\"\r\n              }`\r\n            )\r\n          );\r\n        };\r\n      } catch (error) {\r\n        console.error(\"IndexedDB transaction error:\", error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async saveToFallback(fileData) {\r\n    try {\r\n      this.memoryStorage.set(fileData.id.toString(), fileData);\r\n\r\n      console.log(\r\n        `Saved file ${fileData.name} to memory storage (fallback mode)`\r\n      );\r\n\r\n      this.updateStorageInfo();\r\n      return fileData;\r\n    } catch (error) {\r\n      console.error(\"Fallback save error:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getFilesByType(type) {\r\n    if (this.fallbackMode) {\r\n      return this.getFromFallback(type);\r\n    } else {\r\n      return this.getFromIndexedDB(type);\r\n    }\r\n  }\r\n\r\n  async getFromIndexedDB(type) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction([\"files\"], \"readonly\");\r\n        const store = transaction.objectStore(\"files\");\r\n        \r\n        // ✅ Используем mediaType индекс если он существует, иначе type\r\n        let index;\r\n        try {\r\n          index = store.index(\"mediaType\");\r\n        } catch (e) {\r\n          index = store.index(\"type\");\r\n        }\r\n        \r\n        const request = index.getAll(type);\r\n\r\n        request.onsuccess = () => {\r\n          const now = new Date();\r\n          const validFiles = request.result.filter((file) => {\r\n            return new Date(file.expiresAt) > now;\r\n          });\r\n          resolve(validFiles);\r\n        };\r\n\r\n        request.onerror = () => {\r\n          console.error(\"IndexedDB get error:\", request.error);\r\n          reject(\r\n            new Error(\r\n              `Failed to get from IndexedDB: ${\r\n                request.error?.message || \"Unknown error\"\r\n              }`\r\n            )\r\n          );\r\n        };\r\n      } catch (error) {\r\n        console.error(\"IndexedDB get transaction error:\", error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async getFromFallback(type) {\r\n    const now = new Date();\r\n    const files = [];\r\n\r\n    for (const [key, file] of this.memoryStorage.entries()) {\r\n      // ✅ Проверяем как mediaType, так и type для совместимости\r\n      const fileType = file.mediaType || file.type;\r\n      if (fileType === type && new Date(file.expiresAt) > now) {\r\n        files.push(file);\r\n      }\r\n    }\r\n\r\n    return files;\r\n  }\r\n\r\n  async getAllFiles() {\r\n    try {\r\n      const videos = await this.getFilesByType(\"videos\");\r\n      const images = await this.getFilesByType(\"images\");\r\n      const audios = await this.getFilesByType(\"audios\");\r\n\r\n      return { videos, images, audios };\r\n    } catch (error) {\r\n      console.error(\"Get all files error:\", error);\r\n      return { videos: [], images: [], audios: [] };\r\n    }\r\n  }\r\n\r\n  async deleteFile(id) {\r\n    if (this.fallbackMode) {\r\n      return this.deleteFromFallback(id);\r\n    } else {\r\n      return this.deleteFromIndexedDB(id);\r\n    }\r\n  }\r\n\r\n  async deleteFromIndexedDB(id) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction([\"files\"], \"readwrite\");\r\n        const store = transaction.objectStore(\"files\");\r\n        const request = store.delete(id);\r\n\r\n        request.onsuccess = () => {\r\n          this.updateStorageInfo();\r\n          resolve();\r\n        };\r\n\r\n        request.onerror = () => {\r\n          console.error(\"IndexedDB delete error:\", request.error);\r\n          reject(\r\n            new Error(\r\n              `Failed to delete from IndexedDB: ${\r\n                request.error?.message || \"Unknown error\"\r\n              }`\r\n            )\r\n          );\r\n        };\r\n      } catch (error) {\r\n        console.error(\"IndexedDB delete transaction error:\", error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async deleteFromFallback(id) {\r\n    try {\r\n      const file = this.memoryStorage.get(id.toString());\r\n      if (file && file.url) {\r\n        URL.revokeObjectURL(file.url);\r\n      }\r\n\r\n      this.memoryStorage.delete(id.toString());\r\n      this.updateStorageInfo();\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"Fallback delete error:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async cleanupExpiredFiles() {\r\n    try {\r\n      const now = new Date();\r\n      let expiredCount = 0;\r\n\r\n      if (this.fallbackMode) {\r\n        const keysToDelete = [];\r\n        for (const [key, file] of this.memoryStorage.entries()) {\r\n          if (new Date(file.expiresAt) <= now) {\r\n            keysToDelete.push(key);\r\n            if (file.url) {\r\n              URL.revokeObjectURL(file.url);\r\n            }\r\n          }\r\n        }\r\n\r\n        keysToDelete.forEach((key) => this.memoryStorage.delete(key));\r\n        expiredCount = keysToDelete.length;\r\n      } else {\r\n        const allFiles = await new Promise((resolve) => {\r\n          const transaction = this.db.transaction([\"files\"], \"readonly\");\r\n          const store = transaction.objectStore(\"files\");\r\n          const request = store.getAll();\r\n\r\n          request.onsuccess = () => resolve(request.result || []);\r\n          request.onerror = () => resolve([]);\r\n        });\r\n\r\n        const expiredFiles = allFiles.filter((file) => {\r\n          return new Date(file.expiresAt) <= now;\r\n        });\r\n\r\n        for (const file of expiredFiles) {\r\n          try {\r\n            await this.deleteFromIndexedDB(file.id);\r\n            if (file.url) {\r\n              URL.revokeObjectURL(file.url);\r\n            }\r\n            expiredCount++;\r\n          } catch (deleteError) {\r\n            console.warn(\"Failed to delete expired file:\", deleteError);\r\n          }\r\n        }\r\n      }\r\n\r\n      console.log(`Cleaned up ${expiredCount} expired files`);\r\n      return expiredCount;\r\n    } catch (error) {\r\n      console.error(\"Cleanup error:\", error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async getStorageInfo() {\r\n    try {\r\n      const files = await this.getAllFiles();\r\n      const totalSize = [\r\n        ...files.videos,\r\n        ...files.images,\r\n        ...files.audios,\r\n      ].reduce((sum, file) => sum + file.size, 0);\r\n\r\n      return {\r\n        usage: {\r\n          videos: files.videos.length,\r\n          images: files.images.length,\r\n          audios: files.audios.length,\r\n          totalSize: totalSize,\r\n          totalSizeMB: Math.round(totalSize / (1024 * 1024)),\r\n        },\r\n        limits: this.limits,\r\n        files: files,\r\n        mode: this.fallbackMode ? \"fallback\" : \"indexeddb\",\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Get storage info error:\", error);\r\n      return {\r\n        usage: {\r\n          videos: 0,\r\n          images: 0,\r\n          audios: 0,\r\n          totalSize: 0,\r\n          totalSizeMB: 0,\r\n        },\r\n        limits: this.limits,\r\n        files: { videos: [], images: [], audios: [] },\r\n        mode: this.fallbackMode ? \"fallback\" : \"indexeddb\",\r\n      };\r\n    }\r\n  }\r\n\r\n  async updateStorageInfo() {\r\n    try {\r\n      const info = await this.getStorageInfo();\r\n      window.dispatchEvent(new CustomEvent(\"storageUpdated\", { detail: info }));\r\n    } catch (error) {\r\n      console.error(\"Update storage info error:\", error);\r\n    }\r\n  }\r\n\r\n  async getVideoDuration(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const video = document.createElement(\"video\");\r\n        video.preload = \"metadata\";\r\n\r\n        const timeout = setTimeout(() => {\r\n          video.src = \"\";\r\n          resolve(10);\r\n        }, 5000);\r\n\r\n        video.onloadedmetadata = () => {\r\n          clearTimeout(timeout);\r\n          URL.revokeObjectURL(video.src);\r\n          resolve(video.duration || 10);\r\n        };\r\n\r\n        video.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve(10);\r\n        };\r\n\r\n        video.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn(\"Video duration error:\", error);\r\n        resolve(10);\r\n      }\r\n    });\r\n  }\r\n\r\n  // ✅ Добавляем метод для получения длительности аудио\r\n  async getAudioDuration(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const audio = document.createElement(\"audio\");\r\n        audio.preload = \"metadata\";\r\n\r\n        const timeout = setTimeout(() => {\r\n          audio.src = \"\";\r\n          resolve(10);\r\n        }, 5000);\r\n\r\n        audio.onloadedmetadata = () => {\r\n          clearTimeout(timeout);\r\n          URL.revokeObjectURL(audio.src);\r\n          resolve(audio.duration || 10);\r\n        };\r\n\r\n        audio.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve(10);\r\n        };\r\n\r\n        audio.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn(\"Audio duration error:\", error);\r\n        resolve(10);\r\n      }\r\n    });\r\n  }\r\n\r\n  async getImageDimensions(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const img = new Image();\r\n\r\n        const timeout = setTimeout(() => {\r\n          img.src = \"\";\r\n          resolve({ width: 0, height: 0 });\r\n        }, 5000);\r\n\r\n        img.onload = () => {\r\n          clearTimeout(timeout);\r\n          URL.revokeObjectURL(img.src);\r\n          resolve({ width: img.width, height: img.height });\r\n        };\r\n\r\n        img.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve({ width: 0, height: 0 });\r\n        };\r\n\r\n        img.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn(\"Image dimensions error:\", error);\r\n        resolve({ width: 0, height: 0 });\r\n      }\r\n    });\r\n  }\r\n\r\n  async canUpload(type) {\r\n    try {\r\n      const files = await this.getFilesByType(type);\r\n      return files.length < this.limits[type];\r\n    } catch (error) {\r\n      console.error(\"Can upload check error:\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async getRemainingSpace(type) {\r\n    try {\r\n      const files = await this.getFilesByType(type);\r\n      return this.limits[type] - files.length;\r\n    } catch (error) {\r\n      console.error(\"Get remaining space error:\", error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // ✅ Добавляем метод для проверки размера файла\r\n  formatFileSize(bytes) {\r\n    if (bytes === 0) return '0 Bytes';\r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n}\r\n\r\nexport default new MediaStorage();"],"mappings":"AAAA,MAAMA,YAAY,CAAC;EACjBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,eAAe;IAC7B,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,EAAE,GAAG,IAAI;IACd,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC9B,IAAI,CAACC,MAAM,GAAG;MACZC,MAAM,EAAE,CAAC;MACTC,MAAM,EAAE,EAAE;MACVC,MAAM,EAAE,CAAC;MACTC,WAAW,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI;MAAE;MAChCC,aAAa,EAAE;IACjB,CAAC;EACH;EAEAC,oBAAoBA,CAAA,EAAG;IACrB,OAAO,WAAW,IAAIC,MAAM,IAAIC,SAAS,KAAK,IAAI;EACpD;EAEA,MAAMC,IAAIA,CAAA,EAAG;IACX,IAAI,CAAC,IAAI,CAACH,oBAAoB,CAAC,CAAC,EAAE;MAChCI,OAAO,CAACC,IAAI,CAAC,8CAA8C,CAAC;MAC5D,IAAI,CAACd,YAAY,GAAG,IAAI;MACxB,OAAO,IAAI,CAACe,YAAY,CAAC,CAAC;IAC5B;IAEA,IAAI;MACF,OAAO,MAAM,IAAI,CAACC,aAAa,CAAC,CAAC;IACnC,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdJ,OAAO,CAACC,IAAI,CACV,8DAA8D,EAC9DG,KACF,CAAC;MACD,IAAI,CAACjB,YAAY,GAAG,IAAI;MACxB,OAAO,IAAI,CAACe,YAAY,CAAC,CAAC;IAC5B;EACF;EAEA,MAAMC,aAAaA,CAAA,EAAG;IACpB,OAAO,IAAIE,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,MAAMC,OAAO,GAAGV,SAAS,CAACW,IAAI,CAAC,IAAI,CAACzB,MAAM,EAAE,IAAI,CAACC,OAAO,CAAC;QAEzDuB,OAAO,CAACE,OAAO,GAAG,MAAM;UAAA,IAAAC,cAAA;UACtBX,OAAO,CAACI,KAAK,CAAC,kBAAkB,EAAEI,OAAO,CAACJ,KAAK,CAAC;UAChDG,MAAM,CACJ,IAAIK,KAAK,CACP,oBAAoB,EAAAD,cAAA,GAAAH,OAAO,CAACJ,KAAK,cAAAO,cAAA,uBAAbA,cAAA,CAAeE,OAAO,KAAI,eAAe,EAC/D,CACF,CAAC;QACH,CAAC;QAEDL,OAAO,CAACM,SAAS,GAAG,MAAM;UACxB,IAAI,CAAC5B,EAAE,GAAGsB,OAAO,CAACO,MAAM;UACxBf,OAAO,CAACgB,GAAG,CAAC,oCAAoC,CAAC;UACjDV,OAAO,CAAC,IAAI,CAACpB,EAAE,CAAC;QAClB,CAAC;QAEDsB,OAAO,CAACS,eAAe,GAAIC,KAAK,IAAK;UACnC,IAAI;YACF,MAAMhC,EAAE,GAAGgC,KAAK,CAACC,MAAM,CAACJ,MAAM;YAE9B,IAAI,CAAC7B,EAAE,CAACkC,gBAAgB,CAACC,QAAQ,CAAC,OAAO,CAAC,EAAE;cAC1C,MAAMC,SAAS,GAAGpC,EAAE,CAACqC,iBAAiB,CAAC,OAAO,EAAE;gBAC9CC,OAAO,EAAE;cACX,CAAC,CAAC;cACFF,SAAS,CAACG,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC;cACrCH,SAAS,CAACG,WAAW,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;cACjDH,SAAS,CAACG,WAAW,CAAC,WAAW,EAAE,WAAW,CAAC;cAC/CzB,OAAO,CAACgB,GAAG,CAAC,yBAAyB,CAAC;YACxC;UACF,CAAC,CAAC,OAAOU,YAAY,EAAE;YACrB1B,OAAO,CAACI,KAAK,CAAC,0BAA0B,EAAEsB,YAAY,CAAC;YACvDnB,MAAM,CAACmB,YAAY,CAAC;UACtB;QACF,CAAC;QAEDlB,OAAO,CAACmB,SAAS,GAAG,MAAM;UACxB3B,OAAO,CAACC,IAAI,CAAC,6CAA6C,CAAC;UAC3DM,MAAM,CAAC,IAAIK,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACvD,CAAC;MACH,CAAC,CAAC,OAAOR,KAAK,EAAE;QACdJ,OAAO,CAACI,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;QACvDG,MAAM,CAACH,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEA,MAAMF,YAAYA,CAAA,EAAG;IACnBF,OAAO,CAACgB,GAAG,CAAC,oCAAoC,CAAC;IACjD,IAAI,CAAC7B,YAAY,GAAG,IAAI;IAExB,IAAI,CAACC,aAAa,CAACwC,KAAK,CAAC,CAAC;IAE1B,IAAI;MACFC,YAAY,CAACC,UAAU,CAAC,YAAY,CAAC;MACrC9B,OAAO,CAACgB,GAAG,CAAC,+CAA+C,CAAC;IAC9D,CAAC,CAAC,OAAOZ,KAAK,EAAE;MACdJ,OAAO,CAACC,IAAI,CAAC,+BAA+B,EAAEG,KAAK,CAAC;IACtD;IAEA,OAAO,IAAI;EACb;;EAEA;EACA2B,aAAaA,CAACC,IAAI,EAAE;IAClB,IAAIA,IAAI,CAACC,IAAI,GAAG,IAAI,CAAC3C,MAAM,CAACI,WAAW,EAAE;MACvC,MAAMwC,MAAM,GAAG,CAACF,IAAI,CAACC,IAAI,IAAI,IAAI,GAAG,IAAI,CAAC,EAAEE,OAAO,CAAC,CAAC,CAAC;MACrD,MAAMC,OAAO,GAAG,CAAC,IAAI,CAAC9C,MAAM,CAACI,WAAW,IAAI,IAAI,GAAG,IAAI,CAAC,EAAEyC,OAAO,CAAC,CAAC,CAAC;MACpE,MAAM,IAAIvB,KAAK,CACb,8BAA8BsB,MAAM,iBAAiBE,OAAO,IAC9D,CAAC;IACH;EACF;EAEA,MAAMC,QAAQA,CAACL,IAAI,EAAEM,IAAI,EAAE;IACzB;IACA,IAAI,CAACP,aAAa,CAACC,IAAI,CAAC;IAExB,MAAMO,YAAY,GAAG,MAAM,IAAI,CAACC,cAAc,CAACF,IAAI,CAAC;IACpD,IAAIC,YAAY,CAACE,MAAM,IAAI,IAAI,CAACnD,MAAM,CAACgD,IAAI,CAAC,EAAE;MAC5C,MAAM,IAAI1B,KAAK,CACb,8BAA8B,IAAI,CAACtB,MAAM,CAACgD,IAAI,CAAC,IAAIA,IAAI,WACzD,CAAC;IACH;IAEA,MAAMI,QAAQ,GAAG;MACfC,EAAE,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC;MAC9BC,IAAI,EAAEhB,IAAI,CAACgB,IAAI;MACfV,IAAI,EAAEA,IAAI;MAAE;MACZW,SAAS,EAAEX,IAAI;MAAE;MACjBL,IAAI,EAAED,IAAI,CAACC,IAAI;MACfiB,QAAQ,EAAElB,IAAI,CAACM,IAAI;MACnBa,IAAI,EAAEnB,IAAI;MACVoB,GAAG,EAAEC,GAAG,CAACC,eAAe,CAACtB,IAAI,CAAC;MAC9BuB,SAAS,EAAE,IAAIX,IAAI,CAAC,CAAC,CAACY,WAAW,CAAC,CAAC;MACnCC,SAAS,EAAE,IAAIb,IAAI,CACjBA,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACvD,MAAM,CAACK,aAAa,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAC1D,CAAC,CAAC6D,WAAW,CAAC;IAChB,CAAC;IAED,IAAI;MACF,IAAIlB,IAAI,KAAK,QAAQ,EAAE;QACrBI,QAAQ,CAACgB,QAAQ,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAAC3B,IAAI,CAAC;MACvD,CAAC,MAAM,IAAIM,IAAI,KAAK,QAAQ,EAAE;QAC5BI,QAAQ,CAACgB,QAAQ,GAAG,MAAM,IAAI,CAACE,gBAAgB,CAAC5B,IAAI,CAAC;MACvD,CAAC,MAAM,IAAIM,IAAI,KAAK,QAAQ,EAAE;QAC5B,MAAMuB,UAAU,GAAG,MAAM,IAAI,CAACC,kBAAkB,CAAC9B,IAAI,CAAC;QACtDU,QAAQ,CAACqB,KAAK,GAAGF,UAAU,CAACE,KAAK;QACjCrB,QAAQ,CAACsB,MAAM,GAAGH,UAAU,CAACG,MAAM;MACrC;IACF,CAAC,CAAC,OAAOC,SAAS,EAAE;MAClBjE,OAAO,CAACC,IAAI,CAAC,8BAA8B,EAAEgE,SAAS,CAAC;IACzD;IAEA,IAAI,IAAI,CAAC9E,YAAY,EAAE;MACrB,OAAO,IAAI,CAAC+E,cAAc,CAACxB,QAAQ,CAAC;IACtC,CAAC,MAAM;MACL,OAAO,IAAI,CAACyB,eAAe,CAACzB,QAAQ,CAAC;IACvC;EACF;EAEA,MAAMyB,eAAeA,CAACzB,QAAQ,EAAE;IAC9B,OAAO,IAAIrC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,MAAM6D,WAAW,GAAG,IAAI,CAAClF,EAAE,CAACkF,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,WAAW,CAAC;QAC/D,MAAMC,KAAK,GAAGD,WAAW,CAACE,WAAW,CAAC,OAAO,CAAC;QAC9C,MAAM9D,OAAO,GAAG6D,KAAK,CAACE,GAAG,CAAC7B,QAAQ,CAAC;QAEnClC,OAAO,CAACM,SAAS,GAAG,MAAM;UACxB,IAAI,CAAC0D,iBAAiB,CAAC,CAAC;UACxBlE,OAAO,CAACoC,QAAQ,CAAC;QACnB,CAAC;QAEDlC,OAAO,CAACE,OAAO,GAAG,MAAM;UAAA,IAAA+D,eAAA;UACtBzE,OAAO,CAACI,KAAK,CAAC,uBAAuB,EAAEI,OAAO,CAACJ,KAAK,CAAC;UACrDG,MAAM,CACJ,IAAIK,KAAK,CACP,gCACE,EAAA6D,eAAA,GAAAjE,OAAO,CAACJ,KAAK,cAAAqE,eAAA,uBAAbA,eAAA,CAAe5D,OAAO,KAAI,eAAe,EAE7C,CACF,CAAC;QACH,CAAC;MACH,CAAC,CAAC,OAAOT,KAAK,EAAE;QACdJ,OAAO,CAACI,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;QACpDG,MAAM,CAACH,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEA,MAAM8D,cAAcA,CAACxB,QAAQ,EAAE;IAC7B,IAAI;MACF,IAAI,CAACtD,aAAa,CAACsF,GAAG,CAAChC,QAAQ,CAACC,EAAE,CAACgC,QAAQ,CAAC,CAAC,EAAEjC,QAAQ,CAAC;MAExD1C,OAAO,CAACgB,GAAG,CACT,cAAc0B,QAAQ,CAACM,IAAI,oCAC7B,CAAC;MAED,IAAI,CAACwB,iBAAiB,CAAC,CAAC;MACxB,OAAO9B,QAAQ;IACjB,CAAC,CAAC,OAAOtC,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5C,MAAMA,KAAK;IACb;EACF;EAEA,MAAMoC,cAAcA,CAACF,IAAI,EAAE;IACzB,IAAI,IAAI,CAACnD,YAAY,EAAE;MACrB,OAAO,IAAI,CAACyF,eAAe,CAACtC,IAAI,CAAC;IACnC,CAAC,MAAM;MACL,OAAO,IAAI,CAACuC,gBAAgB,CAACvC,IAAI,CAAC;IACpC;EACF;EAEA,MAAMuC,gBAAgBA,CAACvC,IAAI,EAAE;IAC3B,OAAO,IAAIjC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,MAAM6D,WAAW,GAAG,IAAI,CAAClF,EAAE,CAACkF,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC;QAC9D,MAAMC,KAAK,GAAGD,WAAW,CAACE,WAAW,CAAC,OAAO,CAAC;;QAE9C;QACA,IAAIQ,KAAK;QACT,IAAI;UACFA,KAAK,GAAGT,KAAK,CAACS,KAAK,CAAC,WAAW,CAAC;QAClC,CAAC,CAAC,OAAOC,CAAC,EAAE;UACVD,KAAK,GAAGT,KAAK,CAACS,KAAK,CAAC,MAAM,CAAC;QAC7B;QAEA,MAAMtE,OAAO,GAAGsE,KAAK,CAACE,MAAM,CAAC1C,IAAI,CAAC;QAElC9B,OAAO,CAACM,SAAS,GAAG,MAAM;UACxB,MAAM+B,GAAG,GAAG,IAAID,IAAI,CAAC,CAAC;UACtB,MAAMqC,UAAU,GAAGzE,OAAO,CAACO,MAAM,CAACmE,MAAM,CAAElD,IAAI,IAAK;YACjD,OAAO,IAAIY,IAAI,CAACZ,IAAI,CAACyB,SAAS,CAAC,GAAGZ,GAAG;UACvC,CAAC,CAAC;UACFvC,OAAO,CAAC2E,UAAU,CAAC;QACrB,CAAC;QAEDzE,OAAO,CAACE,OAAO,GAAG,MAAM;UAAA,IAAAyE,eAAA;UACtBnF,OAAO,CAACI,KAAK,CAAC,sBAAsB,EAAEI,OAAO,CAACJ,KAAK,CAAC;UACpDG,MAAM,CACJ,IAAIK,KAAK,CACP,iCACE,EAAAuE,eAAA,GAAA3E,OAAO,CAACJ,KAAK,cAAA+E,eAAA,uBAAbA,eAAA,CAAetE,OAAO,KAAI,eAAe,EAE7C,CACF,CAAC;QACH,CAAC;MACH,CAAC,CAAC,OAAOT,KAAK,EAAE;QACdJ,OAAO,CAACI,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;QACxDG,MAAM,CAACH,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEA,MAAMwE,eAAeA,CAACtC,IAAI,EAAE;IAC1B,MAAMO,GAAG,GAAG,IAAID,IAAI,CAAC,CAAC;IACtB,MAAMwC,KAAK,GAAG,EAAE;IAEhB,KAAK,MAAM,CAACC,GAAG,EAAErD,IAAI,CAAC,IAAI,IAAI,CAAC5C,aAAa,CAACkG,OAAO,CAAC,CAAC,EAAE;MACtD;MACA,MAAMC,QAAQ,GAAGvD,IAAI,CAACiB,SAAS,IAAIjB,IAAI,CAACM,IAAI;MAC5C,IAAIiD,QAAQ,KAAKjD,IAAI,IAAI,IAAIM,IAAI,CAACZ,IAAI,CAACyB,SAAS,CAAC,GAAGZ,GAAG,EAAE;QACvDuC,KAAK,CAACI,IAAI,CAACxD,IAAI,CAAC;MAClB;IACF;IAEA,OAAOoD,KAAK;EACd;EAEA,MAAMK,WAAWA,CAAA,EAAG;IAClB,IAAI;MACF,MAAMlG,MAAM,GAAG,MAAM,IAAI,CAACiD,cAAc,CAAC,QAAQ,CAAC;MAClD,MAAMhD,MAAM,GAAG,MAAM,IAAI,CAACgD,cAAc,CAAC,QAAQ,CAAC;MAClD,MAAM/C,MAAM,GAAG,MAAM,IAAI,CAAC+C,cAAc,CAAC,QAAQ,CAAC;MAElD,OAAO;QAAEjD,MAAM;QAAEC,MAAM;QAAEC;MAAO,CAAC;IACnC,CAAC,CAAC,OAAOW,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5C,OAAO;QAAEb,MAAM,EAAE,EAAE;QAAEC,MAAM,EAAE,EAAE;QAAEC,MAAM,EAAE;MAAG,CAAC;IAC/C;EACF;EAEA,MAAMiG,UAAUA,CAAC/C,EAAE,EAAE;IACnB,IAAI,IAAI,CAACxD,YAAY,EAAE;MACrB,OAAO,IAAI,CAACwG,kBAAkB,CAAChD,EAAE,CAAC;IACpC,CAAC,MAAM;MACL,OAAO,IAAI,CAACiD,mBAAmB,CAACjD,EAAE,CAAC;IACrC;EACF;EAEA,MAAMiD,mBAAmBA,CAACjD,EAAE,EAAE;IAC5B,OAAO,IAAItC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,MAAM6D,WAAW,GAAG,IAAI,CAAClF,EAAE,CAACkF,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,WAAW,CAAC;QAC/D,MAAMC,KAAK,GAAGD,WAAW,CAACE,WAAW,CAAC,OAAO,CAAC;QAC9C,MAAM9D,OAAO,GAAG6D,KAAK,CAACwB,MAAM,CAAClD,EAAE,CAAC;QAEhCnC,OAAO,CAACM,SAAS,GAAG,MAAM;UACxB,IAAI,CAAC0D,iBAAiB,CAAC,CAAC;UACxBlE,OAAO,CAAC,CAAC;QACX,CAAC;QAEDE,OAAO,CAACE,OAAO,GAAG,MAAM;UAAA,IAAAoF,eAAA;UACtB9F,OAAO,CAACI,KAAK,CAAC,yBAAyB,EAAEI,OAAO,CAACJ,KAAK,CAAC;UACvDG,MAAM,CACJ,IAAIK,KAAK,CACP,oCACE,EAAAkF,eAAA,GAAAtF,OAAO,CAACJ,KAAK,cAAA0F,eAAA,uBAAbA,eAAA,CAAejF,OAAO,KAAI,eAAe,EAE7C,CACF,CAAC;QACH,CAAC;MACH,CAAC,CAAC,OAAOT,KAAK,EAAE;QACdJ,OAAO,CAACI,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;QAC3DG,MAAM,CAACH,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEA,MAAMuF,kBAAkBA,CAAChD,EAAE,EAAE;IAC3B,IAAI;MACF,MAAMX,IAAI,GAAG,IAAI,CAAC5C,aAAa,CAAC2G,GAAG,CAACpD,EAAE,CAACgC,QAAQ,CAAC,CAAC,CAAC;MAClD,IAAI3C,IAAI,IAAIA,IAAI,CAACoB,GAAG,EAAE;QACpBC,GAAG,CAAC2C,eAAe,CAAChE,IAAI,CAACoB,GAAG,CAAC;MAC/B;MAEA,IAAI,CAAChE,aAAa,CAACyG,MAAM,CAAClD,EAAE,CAACgC,QAAQ,CAAC,CAAC,CAAC;MACxC,IAAI,CAACH,iBAAiB,CAAC,CAAC;MACxB,OAAO,IAAI;IACb,CAAC,CAAC,OAAOpE,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,MAAMA,KAAK;IACb;EACF;EAEA,MAAM6F,mBAAmBA,CAAA,EAAG;IAC1B,IAAI;MACF,MAAMpD,GAAG,GAAG,IAAID,IAAI,CAAC,CAAC;MACtB,IAAIsD,YAAY,GAAG,CAAC;MAEpB,IAAI,IAAI,CAAC/G,YAAY,EAAE;QACrB,MAAMgH,YAAY,GAAG,EAAE;QACvB,KAAK,MAAM,CAACd,GAAG,EAAErD,IAAI,CAAC,IAAI,IAAI,CAAC5C,aAAa,CAACkG,OAAO,CAAC,CAAC,EAAE;UACtD,IAAI,IAAI1C,IAAI,CAACZ,IAAI,CAACyB,SAAS,CAAC,IAAIZ,GAAG,EAAE;YACnCsD,YAAY,CAACX,IAAI,CAACH,GAAG,CAAC;YACtB,IAAIrD,IAAI,CAACoB,GAAG,EAAE;cACZC,GAAG,CAAC2C,eAAe,CAAChE,IAAI,CAACoB,GAAG,CAAC;YAC/B;UACF;QACF;QAEA+C,YAAY,CAACC,OAAO,CAAEf,GAAG,IAAK,IAAI,CAACjG,aAAa,CAACyG,MAAM,CAACR,GAAG,CAAC,CAAC;QAC7Da,YAAY,GAAGC,YAAY,CAAC1D,MAAM;MACpC,CAAC,MAAM;QACL,MAAM4D,QAAQ,GAAG,MAAM,IAAIhG,OAAO,CAAEC,OAAO,IAAK;UAC9C,MAAM8D,WAAW,GAAG,IAAI,CAAClF,EAAE,CAACkF,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC;UAC9D,MAAMC,KAAK,GAAGD,WAAW,CAACE,WAAW,CAAC,OAAO,CAAC;UAC9C,MAAM9D,OAAO,GAAG6D,KAAK,CAACW,MAAM,CAAC,CAAC;UAE9BxE,OAAO,CAACM,SAAS,GAAG,MAAMR,OAAO,CAACE,OAAO,CAACO,MAAM,IAAI,EAAE,CAAC;UACvDP,OAAO,CAACE,OAAO,GAAG,MAAMJ,OAAO,CAAC,EAAE,CAAC;QACrC,CAAC,CAAC;QAEF,MAAMgG,YAAY,GAAGD,QAAQ,CAACnB,MAAM,CAAElD,IAAI,IAAK;UAC7C,OAAO,IAAIY,IAAI,CAACZ,IAAI,CAACyB,SAAS,CAAC,IAAIZ,GAAG;QACxC,CAAC,CAAC;QAEF,KAAK,MAAMb,IAAI,IAAIsE,YAAY,EAAE;UAC/B,IAAI;YACF,MAAM,IAAI,CAACV,mBAAmB,CAAC5D,IAAI,CAACW,EAAE,CAAC;YACvC,IAAIX,IAAI,CAACoB,GAAG,EAAE;cACZC,GAAG,CAAC2C,eAAe,CAAChE,IAAI,CAACoB,GAAG,CAAC;YAC/B;YACA8C,YAAY,EAAE;UAChB,CAAC,CAAC,OAAOK,WAAW,EAAE;YACpBvG,OAAO,CAACC,IAAI,CAAC,gCAAgC,EAAEsG,WAAW,CAAC;UAC7D;QACF;MACF;MAEAvG,OAAO,CAACgB,GAAG,CAAC,cAAckF,YAAY,gBAAgB,CAAC;MACvD,OAAOA,YAAY;IACrB,CAAC,CAAC,OAAO9F,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAAC;MACtC,OAAO,CAAC;IACV;EACF;EAEA,MAAMoG,cAAcA,CAAA,EAAG;IACrB,IAAI;MACF,MAAMpB,KAAK,GAAG,MAAM,IAAI,CAACK,WAAW,CAAC,CAAC;MACtC,MAAMgB,SAAS,GAAG,CAChB,GAAGrB,KAAK,CAAC7F,MAAM,EACf,GAAG6F,KAAK,CAAC5F,MAAM,EACf,GAAG4F,KAAK,CAAC3F,MAAM,CAChB,CAACiH,MAAM,CAAC,CAACC,GAAG,EAAE3E,IAAI,KAAK2E,GAAG,GAAG3E,IAAI,CAACC,IAAI,EAAE,CAAC,CAAC;MAE3C,OAAO;QACL2E,KAAK,EAAE;UACLrH,MAAM,EAAE6F,KAAK,CAAC7F,MAAM,CAACkD,MAAM;UAC3BjD,MAAM,EAAE4F,KAAK,CAAC5F,MAAM,CAACiD,MAAM;UAC3BhD,MAAM,EAAE2F,KAAK,CAAC3F,MAAM,CAACgD,MAAM;UAC3BgE,SAAS,EAAEA,SAAS;UACpBI,WAAW,EAAE/D,IAAI,CAACgE,KAAK,CAACL,SAAS,IAAI,IAAI,GAAG,IAAI,CAAC;QACnD,CAAC;QACDnH,MAAM,EAAE,IAAI,CAACA,MAAM;QACnB8F,KAAK,EAAEA,KAAK;QACZ2B,IAAI,EAAE,IAAI,CAAC5H,YAAY,GAAG,UAAU,GAAG;MACzC,CAAC;IACH,CAAC,CAAC,OAAOiB,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,OAAO;QACLwG,KAAK,EAAE;UACLrH,MAAM,EAAE,CAAC;UACTC,MAAM,EAAE,CAAC;UACTC,MAAM,EAAE,CAAC;UACTgH,SAAS,EAAE,CAAC;UACZI,WAAW,EAAE;QACf,CAAC;QACDvH,MAAM,EAAE,IAAI,CAACA,MAAM;QACnB8F,KAAK,EAAE;UAAE7F,MAAM,EAAE,EAAE;UAAEC,MAAM,EAAE,EAAE;UAAEC,MAAM,EAAE;QAAG,CAAC;QAC7CsH,IAAI,EAAE,IAAI,CAAC5H,YAAY,GAAG,UAAU,GAAG;MACzC,CAAC;IACH;EACF;EAEA,MAAMqF,iBAAiBA,CAAA,EAAG;IACxB,IAAI;MACF,MAAMwC,IAAI,GAAG,MAAM,IAAI,CAACR,cAAc,CAAC,CAAC;MACxC3G,MAAM,CAACoH,aAAa,CAAC,IAAIC,WAAW,CAAC,gBAAgB,EAAE;QAAEC,MAAM,EAAEH;MAAK,CAAC,CAAC,CAAC;IAC3E,CAAC,CAAC,OAAO5G,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IACpD;EACF;EAEA,MAAMuD,gBAAgBA,CAAC3B,IAAI,EAAE;IAC3B,OAAO,IAAI3B,OAAO,CAAEC,OAAO,IAAK;MAC9B,IAAI;QACF,MAAM8G,KAAK,GAAGC,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;QAC7CF,KAAK,CAACG,OAAO,GAAG,UAAU;QAE1B,MAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;UAC/BL,KAAK,CAACM,GAAG,GAAG,EAAE;UACdpH,OAAO,CAAC,EAAE,CAAC;QACb,CAAC,EAAE,IAAI,CAAC;QAER8G,KAAK,CAACO,gBAAgB,GAAG,MAAM;UAC7BC,YAAY,CAACJ,OAAO,CAAC;UACrBnE,GAAG,CAAC2C,eAAe,CAACoB,KAAK,CAACM,GAAG,CAAC;UAC9BpH,OAAO,CAAC8G,KAAK,CAAC1D,QAAQ,IAAI,EAAE,CAAC;QAC/B,CAAC;QAED0D,KAAK,CAAC1G,OAAO,GAAG,MAAM;UACpBkH,YAAY,CAACJ,OAAO,CAAC;UACrBlH,OAAO,CAAC,EAAE,CAAC;QACb,CAAC;QAED8G,KAAK,CAACM,GAAG,GAAGrE,GAAG,CAACC,eAAe,CAACtB,IAAI,CAAC;MACvC,CAAC,CAAC,OAAO5B,KAAK,EAAE;QACdJ,OAAO,CAACC,IAAI,CAAC,uBAAuB,EAAEG,KAAK,CAAC;QAC5CE,OAAO,CAAC,EAAE,CAAC;MACb;IACF,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMsD,gBAAgBA,CAAC5B,IAAI,EAAE;IAC3B,OAAO,IAAI3B,OAAO,CAAEC,OAAO,IAAK;MAC9B,IAAI;QACF,MAAMuH,KAAK,GAAGR,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;QAC7CO,KAAK,CAACN,OAAO,GAAG,UAAU;QAE1B,MAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;UAC/BI,KAAK,CAACH,GAAG,GAAG,EAAE;UACdpH,OAAO,CAAC,EAAE,CAAC;QACb,CAAC,EAAE,IAAI,CAAC;QAERuH,KAAK,CAACF,gBAAgB,GAAG,MAAM;UAC7BC,YAAY,CAACJ,OAAO,CAAC;UACrBnE,GAAG,CAAC2C,eAAe,CAAC6B,KAAK,CAACH,GAAG,CAAC;UAC9BpH,OAAO,CAACuH,KAAK,CAACnE,QAAQ,IAAI,EAAE,CAAC;QAC/B,CAAC;QAEDmE,KAAK,CAACnH,OAAO,GAAG,MAAM;UACpBkH,YAAY,CAACJ,OAAO,CAAC;UACrBlH,OAAO,CAAC,EAAE,CAAC;QACb,CAAC;QAEDuH,KAAK,CAACH,GAAG,GAAGrE,GAAG,CAACC,eAAe,CAACtB,IAAI,CAAC;MACvC,CAAC,CAAC,OAAO5B,KAAK,EAAE;QACdJ,OAAO,CAACC,IAAI,CAAC,uBAAuB,EAAEG,KAAK,CAAC;QAC5CE,OAAO,CAAC,EAAE,CAAC;MACb;IACF,CAAC,CAAC;EACJ;EAEA,MAAMwD,kBAAkBA,CAAC9B,IAAI,EAAE;IAC7B,OAAO,IAAI3B,OAAO,CAAEC,OAAO,IAAK;MAC9B,IAAI;QACF,MAAMwH,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;QAEvB,MAAMP,OAAO,GAAGC,UAAU,CAAC,MAAM;UAC/BK,GAAG,CAACJ,GAAG,GAAG,EAAE;UACZpH,OAAO,CAAC;YAAEyD,KAAK,EAAE,CAAC;YAAEC,MAAM,EAAE;UAAE,CAAC,CAAC;QAClC,CAAC,EAAE,IAAI,CAAC;QAER8D,GAAG,CAACE,MAAM,GAAG,MAAM;UACjBJ,YAAY,CAACJ,OAAO,CAAC;UACrBnE,GAAG,CAAC2C,eAAe,CAAC8B,GAAG,CAACJ,GAAG,CAAC;UAC5BpH,OAAO,CAAC;YAAEyD,KAAK,EAAE+D,GAAG,CAAC/D,KAAK;YAAEC,MAAM,EAAE8D,GAAG,CAAC9D;UAAO,CAAC,CAAC;QACnD,CAAC;QAED8D,GAAG,CAACpH,OAAO,GAAG,MAAM;UAClBkH,YAAY,CAACJ,OAAO,CAAC;UACrBlH,OAAO,CAAC;YAAEyD,KAAK,EAAE,CAAC;YAAEC,MAAM,EAAE;UAAE,CAAC,CAAC;QAClC,CAAC;QAED8D,GAAG,CAACJ,GAAG,GAAGrE,GAAG,CAACC,eAAe,CAACtB,IAAI,CAAC;MACrC,CAAC,CAAC,OAAO5B,KAAK,EAAE;QACdJ,OAAO,CAACC,IAAI,CAAC,yBAAyB,EAAEG,KAAK,CAAC;QAC9CE,OAAO,CAAC;UAAEyD,KAAK,EAAE,CAAC;UAAEC,MAAM,EAAE;QAAE,CAAC,CAAC;MAClC;IACF,CAAC,CAAC;EACJ;EAEA,MAAMiE,SAASA,CAAC3F,IAAI,EAAE;IACpB,IAAI;MACF,MAAM8C,KAAK,GAAG,MAAM,IAAI,CAAC5C,cAAc,CAACF,IAAI,CAAC;MAC7C,OAAO8C,KAAK,CAAC3C,MAAM,GAAG,IAAI,CAACnD,MAAM,CAACgD,IAAI,CAAC;IACzC,CAAC,CAAC,OAAOlC,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,OAAO,KAAK;IACd;EACF;EAEA,MAAM8H,iBAAiBA,CAAC5F,IAAI,EAAE;IAC5B,IAAI;MACF,MAAM8C,KAAK,GAAG,MAAM,IAAI,CAAC5C,cAAc,CAACF,IAAI,CAAC;MAC7C,OAAO,IAAI,CAAChD,MAAM,CAACgD,IAAI,CAAC,GAAG8C,KAAK,CAAC3C,MAAM;IACzC,CAAC,CAAC,OAAOrC,KAAK,EAAE;MACdJ,OAAO,CAACI,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD,OAAO,CAAC;IACV;EACF;;EAEA;EACA+H,cAAcA,CAACC,KAAK,EAAE;IACpB,IAAIA,KAAK,KAAK,CAAC,EAAE,OAAO,SAAS;IACjC,MAAMC,CAAC,GAAG,IAAI;IACd,MAAMC,KAAK,GAAG,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACzC,MAAMC,CAAC,GAAGzF,IAAI,CAAC0F,KAAK,CAAC1F,IAAI,CAAC9B,GAAG,CAACoH,KAAK,CAAC,GAAGtF,IAAI,CAAC9B,GAAG,CAACqH,CAAC,CAAC,CAAC;IACnD,OAAOI,UAAU,CAAC,CAACL,KAAK,GAAGtF,IAAI,CAAC4F,GAAG,CAACL,CAAC,EAAEE,CAAC,CAAC,EAAEpG,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGmG,KAAK,CAACC,CAAC,CAAC;EACzE;AACF;AAEA,eAAe,IAAIzJ,YAAY,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}