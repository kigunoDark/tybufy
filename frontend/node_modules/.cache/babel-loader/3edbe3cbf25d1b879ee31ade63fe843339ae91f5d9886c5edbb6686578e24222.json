{"ast":null,"code":"// MediaStorage.js - Умное локальное хранилище для MVP\nclass MediaStorage {\n  constructor() {\n    this.dbName = 'VideoEditorDB';\n    this.version = 1;\n    this.db = null;\n    this.fallbackMode = false; // Режим fallback без IndexedDB\n    this.memoryStorage = new Map(); // In-memory хранилище для fallback\n    this.limits = {\n      videos: 5,\n      images: 10,\n      audios: 5,\n      maxFileSize: 100 * 1024 * 1024,\n      // 100MB\n      retentionDays: 7\n    };\n  }\n\n  // Проверка поддержки IndexedDB\n  isIndexedDBSupported() {\n    return 'indexedDB' in window && indexedDB !== null;\n  }\n\n  // Инициализация IndexedDB или fallback\n  async init() {\n    // Проверяем поддержку IndexedDB\n    if (!this.isIndexedDBSupported()) {\n      console.warn('IndexedDB not supported, using fallback mode');\n      this.fallbackMode = true;\n      return this.initFallback();\n    }\n    try {\n      return await this.initIndexedDB();\n    } catch (error) {\n      console.warn('IndexedDB initialization failed, switching to fallback mode:', error);\n      this.fallbackMode = true;\n      return this.initFallback();\n    }\n  }\n\n  // Инициализация IndexedDB\n  async initIndexedDB() {\n    return new Promise((resolve, reject) => {\n      try {\n        const request = indexedDB.open(this.dbName, this.version);\n        request.onerror = () => {\n          var _request$error;\n          console.error('IndexedDB error:', request.error);\n          reject(new Error(`IndexedDB error: ${((_request$error = request.error) === null || _request$error === void 0 ? void 0 : _request$error.message) || 'Unknown error'}`));\n        };\n        request.onsuccess = () => {\n          this.db = request.result;\n          console.log('IndexedDB initialized successfully');\n          resolve(this.db);\n        };\n        request.onupgradeneeded = event => {\n          try {\n            const db = event.target.result;\n\n            // Создаем store для файлов\n            if (!db.objectStoreNames.contains('files')) {\n              const fileStore = db.createObjectStore('files', {\n                keyPath: 'id'\n              });\n              fileStore.createIndex('type', 'type');\n              fileStore.createIndex('createdAt', 'createdAt');\n              console.log('IndexedDB store created');\n            }\n          } catch (upgradeError) {\n            console.error('IndexedDB upgrade error:', upgradeError);\n            reject(upgradeError);\n          }\n        };\n        request.onblocked = () => {\n          console.warn('IndexedDB blocked - another tab may be open');\n          reject(new Error('IndexedDB blocked by another tab'));\n        };\n      } catch (error) {\n        console.error('IndexedDB initialization error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Инициализация fallback режима\n  async initFallback() {\n    console.log('Initializing fallback storage mode');\n    this.fallbackMode = true;\n\n    // Пытаемся загрузить данные из localStorage\n    try {\n      const savedData = localStorage.getItem('mediaFiles');\n      if (savedData) {\n        const parsedData = JSON.parse(savedData);\n        for (const [key, value] of Object.entries(parsedData)) {\n          this.memoryStorage.set(key, value);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to load from localStorage:', error);\n    }\n    return true;\n  }\n\n  // Сохранить файл\n  async saveFile(file, type) {\n    // Проверяем размер файла\n    if (file.size > this.limits.maxFileSize) {\n      throw new Error(`File too large. Max size: ${this.limits.maxFileSize / (1024 * 1024)}MB`);\n    }\n\n    // Проверяем лимиты\n    const currentFiles = await this.getFilesByType(type);\n    if (currentFiles.length >= this.limits[type]) {\n      throw new Error(`Storage limit reached. Max ${this.limits[type]} ${type} allowed.`);\n    }\n\n    // Создаем объект файла\n    const fileData = {\n      id: Date.now() + Math.random(),\n      name: file.name,\n      type: type,\n      size: file.size,\n      mimetype: file.type,\n      blob: file,\n      // Сохраняем сам файл как blob\n      url: URL.createObjectURL(file),\n      createdAt: new Date().toISOString(),\n      expiresAt: new Date(Date.now() + this.limits.retentionDays * 24 * 60 * 60 * 1000).toISOString()\n    };\n\n    // Добавляем метаданные для видео/изображений\n    try {\n      if (type === 'video') {\n        fileData.duration = await this.getVideoDuration(file);\n      } else if (type === 'image') {\n        const dimensions = await this.getImageDimensions(file);\n        fileData.width = dimensions.width;\n        fileData.height = dimensions.height;\n      }\n    } catch (metaError) {\n      console.warn('Failed to get file metadata:', metaError);\n      // Продолжаем без метаданных\n    }\n\n    // Сохраняем в зависимости от режима\n    if (this.fallbackMode) {\n      return this.saveToFallback(fileData);\n    } else {\n      return this.saveToIndexedDB(fileData);\n    }\n  }\n\n  // Сохранение в IndexedDB\n  async saveToIndexedDB(fileData) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction(['files'], 'readwrite');\n        const store = transaction.objectStore('files');\n        const request = store.add(fileData);\n        request.onsuccess = () => {\n          this.updateStorageInfo();\n          resolve(fileData);\n        };\n        request.onerror = () => {\n          var _request$error2;\n          console.error('IndexedDB save error:', request.error);\n          reject(new Error(`Failed to save to IndexedDB: ${((_request$error2 = request.error) === null || _request$error2 === void 0 ? void 0 : _request$error2.message) || 'Unknown error'}`));\n        };\n      } catch (error) {\n        console.error('IndexedDB transaction error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Сохранение в fallback режиме\n  async saveToFallback(fileData) {\n    try {\n      // Сохраняем в memory storage\n      this.memoryStorage.set(fileData.id.toString(), fileData);\n\n      // Пытаемся сохранить метаданные в localStorage (без blob)\n      try {\n        const metaData = {\n          ...fileData\n        };\n        delete metaData.blob; // Убираем blob для localStorage\n\n        const allMeta = {};\n        for (const [key, value] of this.memoryStorage.entries()) {\n          const valueCopy = {\n            ...value\n          };\n          delete valueCopy.blob;\n          allMeta[key] = valueCopy;\n        }\n        localStorage.setItem('mediaFiles', JSON.stringify(allMeta));\n      } catch (lsError) {\n        console.warn('Failed to save metadata to localStorage:', lsError);\n      }\n      this.updateStorageInfo();\n      return fileData;\n    } catch (error) {\n      console.error('Fallback save error:', error);\n      throw error;\n    }\n  }\n\n  // Получить все файлы определенного типа\n  async getFilesByType(type) {\n    if (this.fallbackMode) {\n      return this.getFromFallback(type);\n    } else {\n      return this.getFromIndexedDB(type);\n    }\n  }\n\n  // Получение из IndexedDB\n  async getFromIndexedDB(type) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction(['files'], 'readonly');\n        const store = transaction.objectStore('files');\n        const index = store.index('type');\n        const request = index.getAll(type);\n        request.onsuccess = () => {\n          // Фильтруем неистекшие файлы\n          const now = new Date();\n          const validFiles = request.result.filter(file => {\n            return new Date(file.expiresAt) > now;\n          });\n          resolve(validFiles);\n        };\n        request.onerror = () => {\n          var _request$error3;\n          console.error('IndexedDB get error:', request.error);\n          reject(new Error(`Failed to get from IndexedDB: ${((_request$error3 = request.error) === null || _request$error3 === void 0 ? void 0 : _request$error3.message) || 'Unknown error'}`));\n        };\n      } catch (error) {\n        console.error('IndexedDB get transaction error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Получение из fallback режима\n  async getFromFallback(type) {\n    const now = new Date();\n    const files = [];\n    for (const [key, file] of this.memoryStorage.entries()) {\n      if (file.type === type && new Date(file.expiresAt) > now) {\n        files.push(file);\n      }\n    }\n    return files;\n  }\n\n  // Получить все файлы\n  async getAllFiles() {\n    try {\n      const videos = await this.getFilesByType('video');\n      const images = await this.getFilesByType('image');\n      const audios = await this.getFilesByType('audio');\n      return {\n        videos,\n        images,\n        audios\n      };\n    } catch (error) {\n      console.error('Get all files error:', error);\n      return {\n        videos: [],\n        images: [],\n        audios: []\n      };\n    }\n  }\n\n  // Удалить файл\n  async deleteFile(id) {\n    if (this.fallbackMode) {\n      return this.deleteFromFallback(id);\n    } else {\n      return this.deleteFromIndexedDB(id);\n    }\n  }\n\n  // Удаление из IndexedDB\n  async deleteFromIndexedDB(id) {\n    return new Promise((resolve, reject) => {\n      try {\n        const transaction = this.db.transaction(['files'], 'readwrite');\n        const store = transaction.objectStore('files');\n        const request = store.delete(id);\n        request.onsuccess = () => {\n          this.updateStorageInfo();\n          resolve();\n        };\n        request.onerror = () => {\n          var _request$error4;\n          console.error('IndexedDB delete error:', request.error);\n          reject(new Error(`Failed to delete from IndexedDB: ${((_request$error4 = request.error) === null || _request$error4 === void 0 ? void 0 : _request$error4.message) || 'Unknown error'}`));\n        };\n      } catch (error) {\n        console.error('IndexedDB delete transaction error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  // Удаление из fallback режима\n  async deleteFromFallback(id) {\n    try {\n      const file = this.memoryStorage.get(id.toString());\n      if (file && file.url) {\n        URL.revokeObjectURL(file.url);\n      }\n      this.memoryStorage.delete(id.toString());\n\n      // Обновляем localStorage\n      try {\n        const allMeta = {};\n        for (const [key, value] of this.memoryStorage.entries()) {\n          const valueCopy = {\n            ...value\n          };\n          delete valueCopy.blob;\n          allMeta[key] = valueCopy;\n        }\n        localStorage.setItem('mediaFiles', JSON.stringify(allMeta));\n      } catch (lsError) {\n        console.warn('Failed to update localStorage after delete:', lsError);\n      }\n      this.updateStorageInfo();\n      return true;\n    } catch (error) {\n      console.error('Fallback delete error:', error);\n      throw error;\n    }\n  }\n\n  // Очистка истекших файлов\n  async cleanupExpiredFiles() {\n    try {\n      const now = new Date();\n      let expiredCount = 0;\n      if (this.fallbackMode) {\n        // Очистка в fallback режиме\n        const keysToDelete = [];\n        for (const [key, file] of this.memoryStorage.entries()) {\n          if (new Date(file.expiresAt) <= now) {\n            keysToDelete.push(key);\n            if (file.url) {\n              URL.revokeObjectURL(file.url);\n            }\n          }\n        }\n        keysToDelete.forEach(key => this.memoryStorage.delete(key));\n        expiredCount = keysToDelete.length;\n      } else {\n        // Очистка в IndexedDB\n        const allFiles = await new Promise(resolve => {\n          const transaction = this.db.transaction(['files'], 'readonly');\n          const store = transaction.objectStore('files');\n          const request = store.getAll();\n          request.onsuccess = () => resolve(request.result || []);\n          request.onerror = () => resolve([]);\n        });\n        const expiredFiles = allFiles.filter(file => {\n          return new Date(file.expiresAt) <= now;\n        });\n        for (const file of expiredFiles) {\n          try {\n            await this.deleteFromIndexedDB(file.id);\n            if (file.url) {\n              URL.revokeObjectURL(file.url);\n            }\n            expiredCount++;\n          } catch (deleteError) {\n            console.warn('Failed to delete expired file:', deleteError);\n          }\n        }\n      }\n      console.log(`Cleaned up ${expiredCount} expired files`);\n      return expiredCount;\n    } catch (error) {\n      console.error('Cleanup error:', error);\n      return 0;\n    }\n  }\n\n  // Получить информацию о хранилище\n  async getStorageInfo() {\n    try {\n      const files = await this.getAllFiles();\n      const totalSize = [...files.videos, ...files.images, ...files.audios].reduce((sum, file) => sum + file.size, 0);\n      return {\n        usage: {\n          videos: files.videos.length,\n          images: files.images.length,\n          audios: files.audios.length,\n          totalSize: totalSize,\n          totalSizeMB: Math.round(totalSize / (1024 * 1024))\n        },\n        limits: this.limits,\n        files: files,\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\n      };\n    } catch (error) {\n      console.error('Get storage info error:', error);\n      return {\n        usage: {\n          videos: 0,\n          images: 0,\n          audios: 0,\n          totalSize: 0,\n          totalSizeMB: 0\n        },\n        limits: this.limits,\n        files: {\n          videos: [],\n          images: [],\n          audios: []\n        },\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\n      };\n    }\n  }\n\n  // Обновить информацию в localStorage\n  async updateStorageInfo() {\n    try {\n      const info = await this.getStorageInfo();\n      localStorage.setItem('mediaStorageInfo', JSON.stringify(info));\n\n      // Отправляем событие для обновления UI\n      window.dispatchEvent(new CustomEvent('storageUpdated', {\n        detail: info\n      }));\n    } catch (error) {\n      console.error('Update storage info error:', error);\n    }\n  }\n\n  // Получить длительность видео\n  async getVideoDuration(file) {\n    return new Promise(resolve => {\n      try {\n        const video = document.createElement('video');\n        video.preload = 'metadata';\n        const timeout = setTimeout(() => {\n          video.src = '';\n          resolve(10); // fallback\n        }, 5000); // 5 секунд таймаут\n\n        video.onloadedmetadata = () => {\n          clearTimeout(timeout);\n          window.URL.revokeObjectURL(video.src);\n          resolve(video.duration || 10);\n        };\n        video.onerror = () => {\n          clearTimeout(timeout);\n          resolve(10); // fallback\n        };\n        video.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn('Video duration error:', error);\n        resolve(10); // fallback\n      }\n    });\n  }\n\n  // Получить размеры изображения\n  async getImageDimensions(file) {\n    return new Promise(resolve => {\n      try {\n        const img = new Image();\n        const timeout = setTimeout(() => {\n          img.src = '';\n          resolve({\n            width: 0,\n            height: 0\n          });\n        }, 5000); // 5 секунд таймаут\n\n        img.onload = () => {\n          clearTimeout(timeout);\n          URL.revokeObjectURL(img.src);\n          resolve({\n            width: img.width,\n            height: img.height\n          });\n        };\n        img.onerror = () => {\n          clearTimeout(timeout);\n          resolve({\n            width: 0,\n            height: 0\n          });\n        };\n        img.src = URL.createObjectURL(file);\n      } catch (error) {\n        console.warn('Image dimensions error:', error);\n        resolve({\n          width: 0,\n          height: 0\n        });\n      }\n    });\n  }\n\n  // Проверить, можно ли загрузить файл\n  async canUpload(type) {\n    try {\n      const files = await this.getFilesByType(type);\n      return files.length < this.limits[type];\n    } catch (error) {\n      console.error('Can upload check error:', error);\n      return false;\n    }\n  }\n\n  // Получить оставшееся место\n  async getRemainingSpace(type) {\n    try {\n      const files = await this.getFilesByType(type);\n      return this.limits[type] - files.length;\n    } catch (error) {\n      console.error('Get remaining space error:', error);\n      return 0;\n    }\n  }\n}\nexport default new MediaStorage();","map":{"version":3,"names":["MediaStorage","constructor","dbName","version","db","fallbackMode","memoryStorage","Map","limits","videos","images","audios","maxFileSize","retentionDays","isIndexedDBSupported","window","indexedDB","init","console","warn","initFallback","initIndexedDB","error","Promise","resolve","reject","request","open","onerror","_request$error","Error","message","onsuccess","result","log","onupgradeneeded","event","target","objectStoreNames","contains","fileStore","createObjectStore","keyPath","createIndex","upgradeError","onblocked","savedData","localStorage","getItem","parsedData","JSON","parse","key","value","Object","entries","set","saveFile","file","type","size","currentFiles","getFilesByType","length","fileData","id","Date","now","Math","random","name","mimetype","blob","url","URL","createObjectURL","createdAt","toISOString","expiresAt","duration","getVideoDuration","dimensions","getImageDimensions","width","height","metaError","saveToFallback","saveToIndexedDB","transaction","store","objectStore","add","updateStorageInfo","_request$error2","toString","metaData","allMeta","valueCopy","setItem","stringify","lsError","getFromFallback","getFromIndexedDB","index","getAll","validFiles","filter","_request$error3","files","push","getAllFiles","deleteFile","deleteFromFallback","deleteFromIndexedDB","delete","_request$error4","get","revokeObjectURL","cleanupExpiredFiles","expiredCount","keysToDelete","forEach","allFiles","expiredFiles","deleteError","getStorageInfo","totalSize","reduce","sum","usage","totalSizeMB","round","mode","info","dispatchEvent","CustomEvent","detail","video","document","createElement","preload","timeout","setTimeout","src","onloadedmetadata","clearTimeout","img","Image","onload","canUpload","getRemainingSpace"],"sources":["C:/Scriptify/ai-content-studio/frontend/src/components/utils/MediaStorage.js"],"sourcesContent":["// MediaStorage.js - Умное локальное хранилище для MVP\r\nclass MediaStorage {\r\n  constructor() {\r\n    this.dbName = 'VideoEditorDB';\r\n    this.version = 1;\r\n    this.db = null;\r\n    this.fallbackMode = false; // Режим fallback без IndexedDB\r\n    this.memoryStorage = new Map(); // In-memory хранилище для fallback\r\n    this.limits = {\r\n      videos: 5,\r\n      images: 10,\r\n      audios: 5,\r\n      maxFileSize: 100 * 1024 * 1024, // 100MB\r\n      retentionDays: 7\r\n    };\r\n  }\r\n\r\n  // Проверка поддержки IndexedDB\r\n  isIndexedDBSupported() {\r\n    return 'indexedDB' in window && indexedDB !== null;\r\n  }\r\n\r\n  // Инициализация IndexedDB или fallback\r\n  async init() {\r\n    // Проверяем поддержку IndexedDB\r\n    if (!this.isIndexedDBSupported()) {\r\n      console.warn('IndexedDB not supported, using fallback mode');\r\n      this.fallbackMode = true;\r\n      return this.initFallback();\r\n    }\r\n\r\n    try {\r\n      return await this.initIndexedDB();\r\n    } catch (error) {\r\n      console.warn('IndexedDB initialization failed, switching to fallback mode:', error);\r\n      this.fallbackMode = true;\r\n      return this.initFallback();\r\n    }\r\n  }\r\n\r\n  // Инициализация IndexedDB\r\n  async initIndexedDB() {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const request = indexedDB.open(this.dbName, this.version);\r\n\r\n        request.onerror = () => {\r\n          console.error('IndexedDB error:', request.error);\r\n          reject(new Error(`IndexedDB error: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n\r\n        request.onsuccess = () => {\r\n          this.db = request.result;\r\n          console.log('IndexedDB initialized successfully');\r\n          resolve(this.db);\r\n        };\r\n\r\n        request.onupgradeneeded = (event) => {\r\n          try {\r\n            const db = event.target.result;\r\n\r\n            // Создаем store для файлов\r\n            if (!db.objectStoreNames.contains('files')) {\r\n              const fileStore = db.createObjectStore('files', { keyPath: 'id' });\r\n              fileStore.createIndex('type', 'type');\r\n              fileStore.createIndex('createdAt', 'createdAt');\r\n              console.log('IndexedDB store created');\r\n            }\r\n          } catch (upgradeError) {\r\n            console.error('IndexedDB upgrade error:', upgradeError);\r\n            reject(upgradeError);\r\n          }\r\n        };\r\n\r\n        request.onblocked = () => {\r\n          console.warn('IndexedDB blocked - another tab may be open');\r\n          reject(new Error('IndexedDB blocked by another tab'));\r\n        };\r\n\r\n      } catch (error) {\r\n        console.error('IndexedDB initialization error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Инициализация fallback режима\r\n  async initFallback() {\r\n    console.log('Initializing fallback storage mode');\r\n    this.fallbackMode = true;\r\n    \r\n    // Пытаемся загрузить данные из localStorage\r\n    try {\r\n      const savedData = localStorage.getItem('mediaFiles');\r\n      if (savedData) {\r\n        const parsedData = JSON.parse(savedData);\r\n        for (const [key, value] of Object.entries(parsedData)) {\r\n          this.memoryStorage.set(key, value);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to load from localStorage:', error);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // Сохранить файл\r\n  async saveFile(file, type) {\r\n    // Проверяем размер файла\r\n    if (file.size > this.limits.maxFileSize) {\r\n      throw new Error(`File too large. Max size: ${this.limits.maxFileSize / (1024 * 1024)}MB`);\r\n    }\r\n\r\n    // Проверяем лимиты\r\n    const currentFiles = await this.getFilesByType(type);\r\n    if (currentFiles.length >= this.limits[type]) {\r\n      throw new Error(`Storage limit reached. Max ${this.limits[type]} ${type} allowed.`);\r\n    }\r\n\r\n    // Создаем объект файла\r\n    const fileData = {\r\n      id: Date.now() + Math.random(),\r\n      name: file.name,\r\n      type: type,\r\n      size: file.size,\r\n      mimetype: file.type,\r\n      blob: file, // Сохраняем сам файл как blob\r\n      url: URL.createObjectURL(file),\r\n      createdAt: new Date().toISOString(),\r\n      expiresAt: new Date(Date.now() + this.limits.retentionDays * 24 * 60 * 60 * 1000).toISOString()\r\n    };\r\n\r\n    // Добавляем метаданные для видео/изображений\r\n    try {\r\n      if (type === 'video') {\r\n        fileData.duration = await this.getVideoDuration(file);\r\n      } else if (type === 'image') {\r\n        const dimensions = await this.getImageDimensions(file);\r\n        fileData.width = dimensions.width;\r\n        fileData.height = dimensions.height;\r\n      }\r\n    } catch (metaError) {\r\n      console.warn('Failed to get file metadata:', metaError);\r\n      // Продолжаем без метаданных\r\n    }\r\n\r\n    // Сохраняем в зависимости от режима\r\n    if (this.fallbackMode) {\r\n      return this.saveToFallback(fileData);\r\n    } else {\r\n      return this.saveToIndexedDB(fileData);\r\n    }\r\n  }\r\n\r\n  // Сохранение в IndexedDB\r\n  async saveToIndexedDB(fileData) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction(['files'], 'readwrite');\r\n        const store = transaction.objectStore('files');\r\n        const request = store.add(fileData);\r\n\r\n        request.onsuccess = () => {\r\n          this.updateStorageInfo();\r\n          resolve(fileData);\r\n        };\r\n        \r\n        request.onerror = () => {\r\n          console.error('IndexedDB save error:', request.error);\r\n          reject(new Error(`Failed to save to IndexedDB: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n      } catch (error) {\r\n        console.error('IndexedDB transaction error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Сохранение в fallback режиме\r\n  async saveToFallback(fileData) {\r\n    try {\r\n      // Сохраняем в memory storage\r\n      this.memoryStorage.set(fileData.id.toString(), fileData);\r\n      \r\n      // Пытаемся сохранить метаданные в localStorage (без blob)\r\n      try {\r\n        const metaData = { ...fileData };\r\n        delete metaData.blob; // Убираем blob для localStorage\r\n        \r\n        const allMeta = {};\r\n        for (const [key, value] of this.memoryStorage.entries()) {\r\n          const valueCopy = { ...value };\r\n          delete valueCopy.blob;\r\n          allMeta[key] = valueCopy;\r\n        }\r\n        \r\n        localStorage.setItem('mediaFiles', JSON.stringify(allMeta));\r\n      } catch (lsError) {\r\n        console.warn('Failed to save metadata to localStorage:', lsError);\r\n      }\r\n\r\n      this.updateStorageInfo();\r\n      return fileData;\r\n    } catch (error) {\r\n      console.error('Fallback save error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Получить все файлы определенного типа\r\n  async getFilesByType(type) {\r\n    if (this.fallbackMode) {\r\n      return this.getFromFallback(type);\r\n    } else {\r\n      return this.getFromIndexedDB(type);\r\n    }\r\n  }\r\n\r\n  // Получение из IndexedDB\r\n  async getFromIndexedDB(type) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction(['files'], 'readonly');\r\n        const store = transaction.objectStore('files');\r\n        const index = store.index('type');\r\n        const request = index.getAll(type);\r\n\r\n        request.onsuccess = () => {\r\n          // Фильтруем неистекшие файлы\r\n          const now = new Date();\r\n          const validFiles = request.result.filter(file => {\r\n            return new Date(file.expiresAt) > now;\r\n          });\r\n          resolve(validFiles);\r\n        };\r\n        \r\n        request.onerror = () => {\r\n          console.error('IndexedDB get error:', request.error);\r\n          reject(new Error(`Failed to get from IndexedDB: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n      } catch (error) {\r\n        console.error('IndexedDB get transaction error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Получение из fallback режима\r\n  async getFromFallback(type) {\r\n    const now = new Date();\r\n    const files = [];\r\n    \r\n    for (const [key, file] of this.memoryStorage.entries()) {\r\n      if (file.type === type && new Date(file.expiresAt) > now) {\r\n        files.push(file);\r\n      }\r\n    }\r\n    \r\n    return files;\r\n  }\r\n\r\n  // Получить все файлы\r\n  async getAllFiles() {\r\n    try {\r\n      const videos = await this.getFilesByType('video');\r\n      const images = await this.getFilesByType('image');\r\n      const audios = await this.getFilesByType('audio');\r\n      \r\n      return { videos, images, audios };\r\n    } catch (error) {\r\n      console.error('Get all files error:', error);\r\n      return { videos: [], images: [], audios: [] };\r\n    }\r\n  }\r\n\r\n  // Удалить файл\r\n  async deleteFile(id) {\r\n    if (this.fallbackMode) {\r\n      return this.deleteFromFallback(id);\r\n    } else {\r\n      return this.deleteFromIndexedDB(id);\r\n    }\r\n  }\r\n\r\n  // Удаление из IndexedDB\r\n  async deleteFromIndexedDB(id) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const transaction = this.db.transaction(['files'], 'readwrite');\r\n        const store = transaction.objectStore('files');\r\n        const request = store.delete(id);\r\n\r\n        request.onsuccess = () => {\r\n          this.updateStorageInfo();\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = () => {\r\n          console.error('IndexedDB delete error:', request.error);\r\n          reject(new Error(`Failed to delete from IndexedDB: ${request.error?.message || 'Unknown error'}`));\r\n        };\r\n      } catch (error) {\r\n        console.error('IndexedDB delete transaction error:', error);\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Удаление из fallback режима\r\n  async deleteFromFallback(id) {\r\n    try {\r\n      const file = this.memoryStorage.get(id.toString());\r\n      if (file && file.url) {\r\n        URL.revokeObjectURL(file.url);\r\n      }\r\n      \r\n      this.memoryStorage.delete(id.toString());\r\n      \r\n      // Обновляем localStorage\r\n      try {\r\n        const allMeta = {};\r\n        for (const [key, value] of this.memoryStorage.entries()) {\r\n          const valueCopy = { ...value };\r\n          delete valueCopy.blob;\r\n          allMeta[key] = valueCopy;\r\n        }\r\n        localStorage.setItem('mediaFiles', JSON.stringify(allMeta));\r\n      } catch (lsError) {\r\n        console.warn('Failed to update localStorage after delete:', lsError);\r\n      }\r\n\r\n      this.updateStorageInfo();\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Fallback delete error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Очистка истекших файлов\r\n  async cleanupExpiredFiles() {\r\n    try {\r\n      const now = new Date();\r\n      let expiredCount = 0;\r\n\r\n      if (this.fallbackMode) {\r\n        // Очистка в fallback режиме\r\n        const keysToDelete = [];\r\n        for (const [key, file] of this.memoryStorage.entries()) {\r\n          if (new Date(file.expiresAt) <= now) {\r\n            keysToDelete.push(key);\r\n            if (file.url) {\r\n              URL.revokeObjectURL(file.url);\r\n            }\r\n          }\r\n        }\r\n        \r\n        keysToDelete.forEach(key => this.memoryStorage.delete(key));\r\n        expiredCount = keysToDelete.length;\r\n      } else {\r\n        // Очистка в IndexedDB\r\n        const allFiles = await new Promise((resolve) => {\r\n          const transaction = this.db.transaction(['files'], 'readonly');\r\n          const store = transaction.objectStore('files');\r\n          const request = store.getAll();\r\n          \r\n          request.onsuccess = () => resolve(request.result || []);\r\n          request.onerror = () => resolve([]);\r\n        });\r\n\r\n        const expiredFiles = allFiles.filter(file => {\r\n          return new Date(file.expiresAt) <= now;\r\n        });\r\n\r\n        for (const file of expiredFiles) {\r\n          try {\r\n            await this.deleteFromIndexedDB(file.id);\r\n            if (file.url) {\r\n              URL.revokeObjectURL(file.url);\r\n            }\r\n            expiredCount++;\r\n          } catch (deleteError) {\r\n            console.warn('Failed to delete expired file:', deleteError);\r\n          }\r\n        }\r\n      }\r\n\r\n      console.log(`Cleaned up ${expiredCount} expired files`);\r\n      return expiredCount;\r\n    } catch (error) {\r\n      console.error('Cleanup error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Получить информацию о хранилище\r\n  async getStorageInfo() {\r\n    try {\r\n      const files = await this.getAllFiles();\r\n      const totalSize = [...files.videos, ...files.images, ...files.audios]\r\n        .reduce((sum, file) => sum + file.size, 0);\r\n\r\n      return {\r\n        usage: {\r\n          videos: files.videos.length,\r\n          images: files.images.length,\r\n          audios: files.audios.length,\r\n          totalSize: totalSize,\r\n          totalSizeMB: Math.round(totalSize / (1024 * 1024))\r\n        },\r\n        limits: this.limits,\r\n        files: files,\r\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\r\n      };\r\n    } catch (error) {\r\n      console.error('Get storage info error:', error);\r\n      return {\r\n        usage: { videos: 0, images: 0, audios: 0, totalSize: 0, totalSizeMB: 0 },\r\n        limits: this.limits,\r\n        files: { videos: [], images: [], audios: [] },\r\n        mode: this.fallbackMode ? 'fallback' : 'indexeddb'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Обновить информацию в localStorage\r\n  async updateStorageInfo() {\r\n    try {\r\n      const info = await this.getStorageInfo();\r\n      localStorage.setItem('mediaStorageInfo', JSON.stringify(info));\r\n      \r\n      // Отправляем событие для обновления UI\r\n      window.dispatchEvent(new CustomEvent('storageUpdated', { detail: info }));\r\n    } catch (error) {\r\n      console.error('Update storage info error:', error);\r\n    }\r\n  }\r\n\r\n  // Получить длительность видео\r\n  async getVideoDuration(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const video = document.createElement('video');\r\n        video.preload = 'metadata';\r\n        \r\n        const timeout = setTimeout(() => {\r\n          video.src = '';\r\n          resolve(10); // fallback\r\n        }, 5000); // 5 секунд таймаут\r\n        \r\n        video.onloadedmetadata = () => {\r\n          clearTimeout(timeout);\r\n          window.URL.revokeObjectURL(video.src);\r\n          resolve(video.duration || 10);\r\n        };\r\n        \r\n        video.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve(10); // fallback\r\n        };\r\n        \r\n        video.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn('Video duration error:', error);\r\n        resolve(10); // fallback\r\n      }\r\n    });\r\n  }\r\n\r\n  // Получить размеры изображения\r\n  async getImageDimensions(file) {\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const img = new Image();\r\n        \r\n        const timeout = setTimeout(() => {\r\n          img.src = '';\r\n          resolve({ width: 0, height: 0 });\r\n        }, 5000); // 5 секунд таймаут\r\n        \r\n        img.onload = () => {\r\n          clearTimeout(timeout);\r\n          URL.revokeObjectURL(img.src);\r\n          resolve({ width: img.width, height: img.height });\r\n        };\r\n        \r\n        img.onerror = () => {\r\n          clearTimeout(timeout);\r\n          resolve({ width: 0, height: 0 });\r\n        };\r\n        \r\n        img.src = URL.createObjectURL(file);\r\n      } catch (error) {\r\n        console.warn('Image dimensions error:', error);\r\n        resolve({ width: 0, height: 0 });\r\n      }\r\n    });\r\n  }\r\n\r\n  // Проверить, можно ли загрузить файл\r\n  async canUpload(type) {\r\n    try {\r\n      const files = await this.getFilesByType(type);\r\n      return files.length < this.limits[type];\r\n    } catch (error) {\r\n      console.error('Can upload check error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Получить оставшееся место\r\n  async getRemainingSpace(type) {\r\n    try {\r\n      const files = await this.getFilesByType(type);\r\n      return this.limits[type] - files.length;\r\n    } catch (error) {\r\n      console.error('Get remaining space error:', error);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new MediaStorage();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}