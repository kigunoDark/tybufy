{"ast":null,"code":"var _jsxFileName = \"C:\\\\Scriptify\\\\ai-content-studio\\\\frontend\\\\src\\\\components\\\\Timeline\\\\Timeline.jsx\",\n  _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { TimelineCanvas } from \"./TimelineCanvas\";\nimport { TimelineHeader } from \"./TimelineHeader\";\nimport { TrackLabels } from \"./TrackLabels\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const Timeline = ({\n  timelineItems,\n  setTimelineItems,\n  currentTime,\n  videoDuration,\n  setVideoDuration,\n  selectedTimelineItem,\n  setSelectedTimelineItem,\n  timelineZoom,\n  setTimelineZoom,\n  tracks,\n  setTracks,\n  draggedItem,\n  draggedTimelineItem,\n  setDraggedTimelineItem,\n  dropPreview,\n  setDropPreview,\n  isDragging,\n  isTimelineDragging,\n  setIsTimelineDragging,\n  isResizing,\n  setIsResizing,\n  copiedItem,\n  formatTime,\n  seekTo,\n  splitTimelineItem,\n  copyTimelineItem,\n  pasteTimelineItem,\n  deleteSelectedItem,\n  addToTimeline,\n  insertWithRipple,\n  applyRippleEffect,\n  removeFromTimeline,\n  onSmartAddToTimeline\n}) => {\n  _s();\n  // Хук для экспорта\n  const {\n    isExportModalOpen,\n    openExportModal,\n    closeExportModal\n  } = useVideoExporter();\n\n  // Все существующие refs и состояния...\n  const timelineRef = useRef(null);\n  const timelineScrollRef = useRef(null);\n  const trackLabelsRef = useRef(null);\n  const autoScrollIntervalRef = useRef(null);\n  const [dragOffset, setDragOffset] = useState(0);\n  const [resizeHandle, setResizeHandle] = useState(null);\n  const [resizeItem, setResizeItem] = useState(null);\n  const [originalItemData, setOriginalItemData] = useState(null);\n\n  // Подготовка данных для экспорта\n  const prepareExportData = useCallback(() => {\n    // Добавляем ссылки на медиа элементы к элементам таймлайна\n    const enrichedTimelineItems = timelineItems.map(item => {\n      const enrichedItem = {\n        ...item\n      };\n\n      // Находим соответствующий медиа элемент\n      if (item.type === 'video' && item.src) {\n        // Создаем или находим video элемент\n        enrichedItem.videoElement = document.querySelector(`video[src=\"${item.src}\"]`) || createVideoElement(item.src);\n      } else if (item.type === 'image' && item.src) {\n        // Создаем или находим image элемент\n        enrichedItem.imageElement = document.querySelector(`img[src=\"${item.src}\"]`) || createImageElement(item.src);\n      } else if ((item.type === 'audio' || item.type === 'music') && item.src) {\n        // Создаем или находим audio элемент\n        enrichedItem.audioElement = document.querySelector(`audio[src=\"${item.src}\"]`) || createAudioElement(item.src);\n      }\n      return enrichedItem;\n    });\n    return enrichedTimelineItems;\n  }, [timelineItems]);\n\n  // Функции для создания медиа элементов\n  const createVideoElement = src => {\n    const video = document.createElement('video');\n    video.src = src;\n    video.crossOrigin = 'anonymous';\n    video.muted = true; // Чтобы избежать проблем с autoplay\n    return video;\n  };\n  const createImageElement = src => {\n    const img = document.createElement('img');\n    img.src = src;\n    img.crossOrigin = 'anonymous';\n    return img;\n  };\n  const createAudioElement = src => {\n    const audio = document.createElement('audio');\n    audio.src = src;\n    audio.crossOrigin = 'anonymous';\n    return audio;\n  };\n\n  // Функция для обработки экспорта\n  const handleExportStart = useCallback(async exportSettings => {\n    try {\n      console.log('Начинаем экспорт с настройками:', exportSettings);\n\n      // Подготавливаем данные\n      const enrichedItems = prepareExportData();\n\n      // Создаем экспортер\n      const videoExporter = new VideoExporter({\n        timelineItems: enrichedItems,\n        tracks,\n        videoDuration,\n        settings: exportSettings\n      });\n\n      // Запускаем экспорт\n      const exportedBlob = await videoExporter.render();\n\n      // Скачиваем файл\n      downloadVideo(exportedBlob, exportSettings.format);\n      console.log('Экспорт завершен успешно');\n    } catch (error) {\n      console.error('Ошибка при экспорте:', error);\n      throw error;\n    }\n  }, [prepareExportData, tracks, videoDuration]);\n  const downloadVideo = (blob, format) => {\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `edited_video_${Date.now()}.${format}`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  // Все остальные функции остаются такими же как в предыдущем коде...\n  // (автоскролл, drag&drop, resize, zoom и т.д.)\n\n  const stopAutoScroll = useCallback(() => {\n    if (autoScrollIntervalRef.current) {\n      clearInterval(autoScrollIntervalRef.current);\n      autoScrollIntervalRef.current = null;\n    }\n  }, []);\n  const startAutoScroll = useCallback((direction, speed = 1) => {\n    stopAutoScroll();\n    autoScrollIntervalRef.current = setInterval(() => {\n      if (timelineScrollRef.current) {\n        const scrollAmount = 15 * speed;\n        const currentScrollLeft = timelineScrollRef.current.scrollLeft;\n        const maxScroll = timelineScrollRef.current.scrollWidth - timelineScrollRef.current.clientWidth;\n        if (direction === \"left\" && currentScrollLeft > 0) {\n          timelineScrollRef.current.scrollLeft = Math.max(0, currentScrollLeft - scrollAmount);\n        } else if (direction === \"right\" && currentScrollLeft < maxScroll) {\n          timelineScrollRef.current.scrollLeft = Math.min(maxScroll, currentScrollLeft + scrollAmount);\n        }\n      }\n    }, 16);\n  }, [stopAutoScroll]);\n  const checkAutoScroll = useCallback(clientX => {\n    if (!timelineScrollRef.current) return;\n    const rect = timelineScrollRef.current.getBoundingClientRect();\n    const scrollZoneWidth = 120;\n    const relativeX = clientX - rect.left;\n    if (relativeX < scrollZoneWidth && timelineScrollRef.current.scrollLeft > 0) {\n      const speed = (scrollZoneWidth - relativeX) / scrollZoneWidth * 3;\n      startAutoScroll(\"left\", speed);\n    } else if (relativeX > rect.width - scrollZoneWidth) {\n      const maxScroll = timelineScrollRef.current.scrollWidth - timelineScrollRef.current.clientWidth;\n      if (timelineScrollRef.current.scrollLeft < maxScroll) {\n        const speed = (relativeX - (rect.width - scrollZoneWidth)) / scrollZoneWidth * 3;\n        startAutoScroll(\"right\", speed);\n      }\n    } else {\n      stopAutoScroll();\n    }\n  }, [startAutoScroll, stopAutoScroll]);\n\n  // Утилиты\n  const getTimelineWidth = () => {\n    const baseWidth = videoDuration * 50 * timelineZoom;\n    return Math.max(baseWidth, 2000);\n  };\n  const getPixelsPerSecond = () => {\n    return 50 * timelineZoom;\n  };\n  const getTrackColor = trackType => {\n    switch (trackType) {\n      case \"overlay\":\n        return \"bg-purple-500 border-purple-400\";\n      case \"main\":\n        return \"bg-blue-500 border-blue-400\";\n      case \"audio\":\n        return \"bg-green-500 border-green-400\";\n      default:\n        return \"bg-gray-500 border-gray-400\";\n    }\n  };\n  const getTimelineItemStyle = item => {\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\n    const trackIndex = allTracks.findIndex(track => track.id === item.trackId);\n    const pixelsPerSecond = getPixelsPerSecond();\n    return {\n      left: `${item.startTime * pixelsPerSecond}px`,\n      width: `${item.duration * pixelsPerSecond}px`,\n      top: `${trackIndex * 60 + 10}px`\n    };\n  };\n  const getDropPreviewStyle = () => {\n    if (!dropPreview) return {};\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\n    const trackIndex = allTracks.findIndex(track => track.id === dropPreview.trackId);\n    const pixelsPerSecond = getPixelsPerSecond();\n    return {\n      left: `${dropPreview.time * pixelsPerSecond}px`,\n      width: `${dropPreview.duration * pixelsPerSecond}px`,\n      top: `${trackIndex * 60 + 10}px`\n    };\n  };\n\n  // Zoom функции\n  const zoomIn = () => setTimelineZoom(prev => Math.min(20, prev * 1.5));\n  const zoomOut = () => setTimelineZoom(prev => Math.max(0.1, prev / 1.5));\n  const resetZoom = () => setTimelineZoom(1);\n\n  // Функции для добавления треков\n  const addOverlayTrack = () => {\n    const newTrackId = `overlay-${Date.now()}`;\n    setTracks(prev => ({\n      ...prev,\n      overlays: [...prev.overlays, {\n        id: newTrackId,\n        name: `Overlay ${prev.overlays.length + 1}`,\n        type: \"overlay\"\n      }]\n    }));\n  };\n  const addAudioTrack = () => {\n    const newTrackId = `audio-${Date.now()}`;\n    setTracks(prev => ({\n      ...prev,\n      audio: [...prev.audio, {\n        id: newTrackId,\n        name: `Audio ${prev.audio.length + 1}`,\n        type: \"audio\"\n      }]\n    }));\n  };\n\n  // Остальные обработчики событий остаются такими же...\n  // (handleTimelineClick, handleDragOver, handleDrop и т.д.)\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: `h-80 bg-white rounded-2xl shadow-sm border-2 transition-all duration-200 overflow-hidden flex flex-col flex-shrink-0 ${isDragging || isTimelineDragging || isResizing ? \"border-blue-400 bg-blue-50/20\" : \"border-gray-200\"}`,\n      children: [/*#__PURE__*/_jsxDEV(TimelineHeader, {\n        draggedItem: draggedItem,\n        isDragging: isDragging,\n        isTimelineDragging: isTimelineDragging,\n        isResizing: isResizing,\n        dropPreview: dropPreview,\n        draggedTimelineItem: draggedTimelineItem,\n        resizeItem: resizeItem,\n        resizeHandle: resizeHandle,\n        copiedItem: copiedItem,\n        timelineZoom: timelineZoom,\n        selectedTimelineItem: selectedTimelineItem,\n        onOpenExportModal: openExportModal // Передаем функцию открытия модалки\n        ,\n        addOverlayTrack: addOverlayTrack,\n        addAudioTrack: addAudioTrack,\n        addToTimelineAtCurrentTime: () => {} // implement\n        ,\n        splitTimelineItem: splitTimelineItem,\n        copyTimelineItem: copyTimelineItem,\n        pasteTimelineItem: pasteTimelineItem,\n        deleteSelectedItem: deleteSelectedItem,\n        zoomIn: zoomIn,\n        zoomOut: zoomOut,\n        resetZoom: resetZoom\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"flex-1 flex min-h-0\",\n        children: [/*#__PURE__*/_jsxDEV(TrackLabels, {\n          tracks: tracks,\n          trackLabelsRef: trackLabelsRef,\n          onScroll: () => {} // implement\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 344,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(TimelineCanvas, {\n          timelineRef: timelineRef,\n          timelineScrollRef: timelineScrollRef,\n          tracks: tracks,\n          timelineItems: timelineItems,\n          selectedTimelineItem: selectedTimelineItem,\n          draggedTimelineItem: draggedTimelineItem,\n          copiedItem: copiedItem,\n          dropPreview: dropPreview,\n          getTimelineWidth: getTimelineWidth,\n          getPixelsPerSecond: getPixelsPerSecond,\n          getTrackColor: getTrackColor,\n          getTimelineItemStyle: getTimelineItemStyle,\n          getDropPreviewStyle: getDropPreviewStyle,\n          videoDuration: videoDuration,\n          timelineZoom: timelineZoom,\n          currentTime: currentTime,\n          formatTime: formatTime,\n          onScroll: () => {} // implement\n          ,\n          onDragOver: () => {} // implement\n          ,\n          onDrop: () => {} // implement\n          ,\n          onDragLeave: () => {} // implement\n          ,\n          onClick: () => {} // implement\n          ,\n          onDoubleClick: () => {} // implement\n          ,\n          onTimelineItemSelect: setSelectedTimelineItem,\n          onTimelineItemDragStart: () => {} // implement\n          ,\n          onTimelineItemDragEnd: () => {} // implement\n          ,\n          onResizeStart: () => {} // implement\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 350,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 343,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 311,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(VideoExportModal, {\n      isOpen: isExportModalOpen,\n      onClose: closeExportModal,\n      timelineItems: prepareExportData(),\n      tracks: tracks,\n      videoDuration: videoDuration,\n      onExport: handleExportStart\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 383,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n// Улучшенный VideoExporter класс с поддержкой WebCodecs API\n_s(Timeline, \"q+zPcVe0qefTQMl+cEYgY7imJXg=\", true);\n_c = Timeline;\nclass VideoExporter {\n  constructor({\n    timelineItems,\n    tracks,\n    videoDuration,\n    settings\n  }) {\n    this.timelineItems = timelineItems;\n    this.tracks = tracks;\n    this.videoDuration = videoDuration;\n    this.settings = settings;\n\n    // Проверяем поддержку WebCodecs API\n    this.useWebCodecs = 'VideoEncoder' in window && 'VideoFrame' in window;\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n\n    // Установка размеров canvas\n    const [width, height] = settings.resolution.split('x').map(Number);\n    this.canvas.width = width;\n    this.canvas.height = height;\n  }\n  async render() {\n    if (this.useWebCodecs) {\n      return await this.renderWithWebCodecs();\n    } else {\n      return await this.renderWithMediaRecorder();\n    }\n  }\n  async renderWithWebCodecs() {\n    // Современный способ с WebCodecs API (Chrome 94+)\n    const chunks = [];\n    const videoEncoder = new VideoEncoder({\n      output: chunk => {\n        chunks.push(chunk);\n      },\n      error: error => {\n        console.error('Video encoding error:', error);\n      }\n    });\n    videoEncoder.configure({\n      codec: 'avc1.42001E',\n      // H.264 Baseline\n      width: this.canvas.width,\n      height: this.canvas.height,\n      bitrate: this.settings.bitrate * 1000,\n      framerate: this.settings.fps\n    });\n    const frameCount = Math.ceil(this.videoDuration * this.settings.fps);\n    const frameDuration = 1000000 / this.settings.fps; // в микросекундах\n\n    for (let frame = 0; frame < frameCount; frame++) {\n      const currentTime = frame / this.settings.fps;\n      await this.renderFrame(currentTime);\n      const videoFrame = new VideoFrame(this.canvas, {\n        timestamp: frame * frameDuration\n      });\n      videoEncoder.encode(videoFrame, {\n        keyFrame: frame % 30 === 0\n      });\n      videoFrame.close();\n    }\n    await videoEncoder.flush();\n    videoEncoder.close();\n\n    // Создаем MP4 контейнер (упрощенная версия)\n    return new Blob(chunks, {\n      type: `video/${this.settings.format}`\n    });\n  }\n  async renderWithMediaRecorder() {\n    // Старый способ с MediaRecorder (больше совместимости)\n    const stream = this.canvas.captureStream(this.settings.fps);\n    const options = {\n      mimeType: this.getMimeType(),\n      videoBitsPerSecond: this.settings.bitrate * 1000\n    };\n    const mediaRecorder = new MediaRecorder(stream, options);\n    const chunks = [];\n    mediaRecorder.ondataavailable = event => {\n      if (event.data.size > 0) {\n        chunks.push(event.data);\n      }\n    };\n    return new Promise((resolve, reject) => {\n      mediaRecorder.onstop = () => {\n        const blob = new Blob(chunks, {\n          type: `video/${this.settings.format}`\n        });\n        resolve(blob);\n      };\n      mediaRecorder.onerror = reject;\n      mediaRecorder.start();\n      this.renderFrames().then(() => {\n        mediaRecorder.stop();\n      }).catch(reject);\n    });\n  }\n  getMimeType() {\n    const formats = {\n      mp4: 'video/mp4;codecs=h264',\n      webm: 'video/webm;codecs=vp9',\n      mov: 'video/mp4;codecs=h264'\n    };\n    return formats[this.settings.format] || formats.mp4;\n  }\n  async renderFrames() {\n    const frameCount = Math.ceil(this.videoDuration * this.settings.fps);\n    const frameDuration = 1 / this.settings.fps;\n    for (let frame = 0; frame < frameCount; frame++) {\n      const currentTime = frame * frameDuration;\n      await this.renderFrame(currentTime);\n\n      // Ждем следующий кадр\n      await new Promise(resolve => requestAnimationFrame(resolve));\n    }\n  }\n  async renderFrame(currentTime) {\n    // Очищаем canvas черным фоном\n    this.ctx.fillStyle = '#000000';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Сортируем элементы по слоям\n    const sortedItems = [...this.timelineItems].sort((a, b) => {\n      const order = {\n        main: 1,\n        audio: 2,\n        overlay: 3\n      };\n      return order[a.trackType] - order[b.trackType];\n    });\n\n    // Рендерим каждый активный элемент\n    for (const item of sortedItems) {\n      if (this.isItemActiveAtTime(item, currentTime)) {\n        const relativeTime = currentTime - item.startTime;\n        await this.renderItem(item, relativeTime);\n      }\n    }\n  }\n  isItemActiveAtTime(item, currentTime) {\n    return currentTime >= item.startTime && currentTime < item.startTime + item.duration;\n  }\n  async renderItem(item, relativeTime) {\n    switch (item.type) {\n      case 'video':\n        await this.renderVideo(item, relativeTime);\n        break;\n      case 'image':\n        await this.renderImage(item);\n        break;\n      case 'text':\n        await this.renderText(item);\n        break;\n      // Аудио не рендерится визуально\n    }\n  }\n  async renderVideo(item, relativeTime) {\n    if (!item.videoElement) return;\n    try {\n      // Устанавливаем точное время\n      item.videoElement.currentTime = relativeTime;\n\n      // Ждем загрузки кадра\n      await this.waitForVideoFrame(item.videoElement);\n\n      // Рендерим с масштабированием\n      this.drawScaledMedia(item.videoElement);\n    } catch (error) {\n      console.warn('Ошибка рендеринга видео:', error);\n    }\n  }\n  async renderImage(item) {\n    if (!item.imageElement) return;\n    try {\n      await this.waitForImageLoad(item.imageElement);\n      this.drawScaledMedia(item.imageElement);\n    } catch (error) {\n      console.warn('Ошибка рендеринга изображения:', error);\n    }\n  }\n  async renderText(item) {\n    if (!item.text) return;\n    this.ctx.fillStyle = item.color || '#ffffff';\n    this.ctx.font = `${item.fontSize || 24}px ${item.fontFamily || 'Arial'}`;\n    this.ctx.textAlign = item.textAlign || 'center';\n    const x = this.canvas.width / 2;\n    const y = this.canvas.height / 2;\n    this.ctx.fillText(item.text, x, y);\n  }\n  drawScaledMedia(mediaElement) {\n    // Масштабируем медиа элемент под размер canvas\n    const canvasAspect = this.canvas.width / this.canvas.height;\n    const mediaAspect = mediaElement.videoWidth || mediaElement.naturalWidth || mediaElement.width;\n    const mediaHeight = mediaElement.videoHeight || mediaElement.naturalHeight || mediaElement.height;\n    const mediaAspectRatio = mediaAspect / mediaHeight;\n    let drawWidth, drawHeight, drawX, drawY;\n    if (mediaAspectRatio > canvasAspect) {\n      // Медиа шире canvas\n      drawWidth = this.canvas.width;\n      drawHeight = this.canvas.width / mediaAspectRatio;\n      drawX = 0;\n      drawY = (this.canvas.height - drawHeight) / 2;\n    } else {\n      // Медиа выше canvas\n      drawHeight = this.canvas.height;\n      drawWidth = this.canvas.height * mediaAspectRatio;\n      drawX = (this.canvas.width - drawWidth) / 2;\n      drawY = 0;\n    }\n    this.ctx.drawImage(mediaElement, drawX, drawY, drawWidth, drawHeight);\n  }\n  async waitForVideoFrame(videoElement) {\n    return new Promise(resolve => {\n      const checkReady = () => {\n        if (videoElement.readyState >= 2) {\n          resolve();\n        } else {\n          requestAnimationFrame(checkReady);\n        }\n      };\n      checkReady();\n    });\n  }\n  async waitForImageLoad(imageElement) {\n    return new Promise((resolve, reject) => {\n      if (imageElement.complete) {\n        resolve();\n      } else {\n        imageElement.onload = resolve;\n        imageElement.onerror = reject;\n      }\n    });\n  }\n}\nvar _c;\n$RefreshReg$(_c, \"Timeline\");","map":{"version":3,"names":["useState","useRef","useEffect","useCallback","TimelineCanvas","TimelineHeader","TrackLabels","jsxDEV","_jsxDEV","Fragment","_Fragment","Timeline","timelineItems","setTimelineItems","currentTime","videoDuration","setVideoDuration","selectedTimelineItem","setSelectedTimelineItem","timelineZoom","setTimelineZoom","tracks","setTracks","draggedItem","draggedTimelineItem","setDraggedTimelineItem","dropPreview","setDropPreview","isDragging","isTimelineDragging","setIsTimelineDragging","isResizing","setIsResizing","copiedItem","formatTime","seekTo","splitTimelineItem","copyTimelineItem","pasteTimelineItem","deleteSelectedItem","addToTimeline","insertWithRipple","applyRippleEffect","removeFromTimeline","onSmartAddToTimeline","_s","isExportModalOpen","openExportModal","closeExportModal","useVideoExporter","timelineRef","timelineScrollRef","trackLabelsRef","autoScrollIntervalRef","dragOffset","setDragOffset","resizeHandle","setResizeHandle","resizeItem","setResizeItem","originalItemData","setOriginalItemData","prepareExportData","enrichedTimelineItems","map","item","enrichedItem","type","src","videoElement","document","querySelector","createVideoElement","imageElement","createImageElement","audioElement","createAudioElement","video","createElement","crossOrigin","muted","img","audio","handleExportStart","exportSettings","console","log","enrichedItems","videoExporter","VideoExporter","settings","exportedBlob","render","downloadVideo","format","error","blob","url","URL","createObjectURL","a","href","download","Date","now","body","appendChild","click","removeChild","revokeObjectURL","stopAutoScroll","current","clearInterval","startAutoScroll","direction","speed","setInterval","scrollAmount","currentScrollLeft","scrollLeft","maxScroll","scrollWidth","clientWidth","Math","max","min","checkAutoScroll","clientX","rect","getBoundingClientRect","scrollZoneWidth","relativeX","left","width","getTimelineWidth","baseWidth","getPixelsPerSecond","getTrackColor","trackType","getTimelineItemStyle","allTracks","overlays","main","trackIndex","findIndex","track","id","trackId","pixelsPerSecond","startTime","duration","top","getDropPreviewStyle","time","zoomIn","prev","zoomOut","resetZoom","addOverlayTrack","newTrackId","name","length","addAudioTrack","children","className","onOpenExportModal","addToTimelineAtCurrentTime","fileName","_jsxFileName","lineNumber","columnNumber","onScroll","onDragOver","onDrop","onDragLeave","onClick","onDoubleClick","onTimelineItemSelect","onTimelineItemDragStart","onTimelineItemDragEnd","onResizeStart","VideoExportModal","isOpen","onClose","onExport","_c","constructor","useWebCodecs","window","canvas","ctx","getContext","height","resolution","split","Number","renderWithWebCodecs","renderWithMediaRecorder","chunks","videoEncoder","VideoEncoder","output","chunk","push","configure","codec","bitrate","framerate","fps","frameCount","ceil","frameDuration","frame","renderFrame","videoFrame","VideoFrame","timestamp","encode","keyFrame","close","flush","Blob","stream","captureStream","options","mimeType","getMimeType","videoBitsPerSecond","mediaRecorder","MediaRecorder","ondataavailable","event","data","size","Promise","resolve","reject","onstop","onerror","start","renderFrames","then","stop","catch","formats","mp4","webm","mov","requestAnimationFrame","fillStyle","fillRect","sortedItems","sort","b","order","overlay","isItemActiveAtTime","relativeTime","renderItem","renderVideo","renderImage","renderText","waitForVideoFrame","drawScaledMedia","warn","waitForImageLoad","text","color","font","fontSize","fontFamily","textAlign","x","y","fillText","mediaElement","canvasAspect","mediaAspect","videoWidth","naturalWidth","mediaHeight","videoHeight","naturalHeight","mediaAspectRatio","drawWidth","drawHeight","drawX","drawY","drawImage","checkReady","readyState","complete","onload","$RefreshReg$"],"sources":["C:/Scriptify/ai-content-studio/frontend/src/components/Timeline/Timeline.jsx"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from \"react\";\r\nimport { TimelineCanvas } from \"./TimelineCanvas\";\r\nimport { TimelineHeader } from \"./TimelineHeader\";\r\nimport { TrackLabels } from \"./TrackLabels\";\r\nexport const Timeline = ({\r\n  timelineItems,\r\n  setTimelineItems,\r\n  currentTime,\r\n  videoDuration,\r\n  setVideoDuration,\r\n  selectedTimelineItem,\r\n  setSelectedTimelineItem,\r\n  timelineZoom,\r\n  setTimelineZoom,\r\n  tracks,\r\n  setTracks,\r\n  draggedItem,\r\n  draggedTimelineItem,\r\n  setDraggedTimelineItem,\r\n  dropPreview,\r\n  setDropPreview,\r\n  isDragging,\r\n  isTimelineDragging,\r\n  setIsTimelineDragging,\r\n  isResizing,\r\n  setIsResizing,\r\n  copiedItem,\r\n  formatTime,\r\n  seekTo,\r\n  splitTimelineItem,\r\n  copyTimelineItem,\r\n  pasteTimelineItem,\r\n  deleteSelectedItem,\r\n  addToTimeline,\r\n  insertWithRipple,\r\n  applyRippleEffect,\r\n  removeFromTimeline,\r\n  onSmartAddToTimeline,\r\n}) => {\r\n  // Хук для экспорта\r\n  const { \r\n    isExportModalOpen, \r\n    openExportModal, \r\n    closeExportModal \r\n  } = useVideoExporter();\r\n\r\n  // Все существующие refs и состояния...\r\n  const timelineRef = useRef(null);\r\n  const timelineScrollRef = useRef(null);\r\n  const trackLabelsRef = useRef(null);\r\n  const autoScrollIntervalRef = useRef(null);\r\n\r\n  const [dragOffset, setDragOffset] = useState(0);\r\n  const [resizeHandle, setResizeHandle] = useState(null);\r\n  const [resizeItem, setResizeItem] = useState(null);\r\n  const [originalItemData, setOriginalItemData] = useState(null);\r\n\r\n  // Подготовка данных для экспорта\r\n  const prepareExportData = useCallback(() => {\r\n    // Добавляем ссылки на медиа элементы к элементам таймлайна\r\n    const enrichedTimelineItems = timelineItems.map(item => {\r\n      const enrichedItem = { ...item };\r\n\r\n      // Находим соответствующий медиа элемент\r\n      if (item.type === 'video' && item.src) {\r\n        // Создаем или находим video элемент\r\n        enrichedItem.videoElement = document.querySelector(`video[src=\"${item.src}\"]`) || \r\n          createVideoElement(item.src);\r\n      } else if (item.type === 'image' && item.src) {\r\n        // Создаем или находим image элемент\r\n        enrichedItem.imageElement = document.querySelector(`img[src=\"${item.src}\"]`) || \r\n          createImageElement(item.src);\r\n      } else if ((item.type === 'audio' || item.type === 'music') && item.src) {\r\n        // Создаем или находим audio элемент\r\n        enrichedItem.audioElement = document.querySelector(`audio[src=\"${item.src}\"]`) || \r\n          createAudioElement(item.src);\r\n      }\r\n\r\n      return enrichedItem;\r\n    });\r\n\r\n    return enrichedTimelineItems;\r\n  }, [timelineItems]);\r\n\r\n  // Функции для создания медиа элементов\r\n  const createVideoElement = (src) => {\r\n    const video = document.createElement('video');\r\n    video.src = src;\r\n    video.crossOrigin = 'anonymous';\r\n    video.muted = true; // Чтобы избежать проблем с autoplay\r\n    return video;\r\n  };\r\n\r\n  const createImageElement = (src) => {\r\n    const img = document.createElement('img');\r\n    img.src = src;\r\n    img.crossOrigin = 'anonymous';\r\n    return img;\r\n  };\r\n\r\n  const createAudioElement = (src) => {\r\n    const audio = document.createElement('audio');\r\n    audio.src = src;\r\n    audio.crossOrigin = 'anonymous';\r\n    return audio;\r\n  };\r\n\r\n  // Функция для обработки экспорта\r\n  const handleExportStart = useCallback(async (exportSettings) => {\r\n    try {\r\n      console.log('Начинаем экспорт с настройками:', exportSettings);\r\n      \r\n      // Подготавливаем данные\r\n      const enrichedItems = prepareExportData();\r\n      \r\n      // Создаем экспортер\r\n      const videoExporter = new VideoExporter({\r\n        timelineItems: enrichedItems,\r\n        tracks,\r\n        videoDuration,\r\n        settings: exportSettings\r\n      });\r\n\r\n      // Запускаем экспорт\r\n      const exportedBlob = await videoExporter.render();\r\n      \r\n      // Скачиваем файл\r\n      downloadVideo(exportedBlob, exportSettings.format);\r\n      \r\n      console.log('Экспорт завершен успешно');\r\n    } catch (error) {\r\n      console.error('Ошибка при экспорте:', error);\r\n      throw error;\r\n    }\r\n  }, [prepareExportData, tracks, videoDuration]);\r\n\r\n  const downloadVideo = (blob, format) => {\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement('a');\r\n    a.href = url;\r\n    a.download = `edited_video_${Date.now()}.${format}`;\r\n    document.body.appendChild(a);\r\n    a.click();\r\n    document.body.removeChild(a);\r\n    URL.revokeObjectURL(url);\r\n  };\r\n\r\n  // Все остальные функции остаются такими же как в предыдущем коде...\r\n  // (автоскролл, drag&drop, resize, zoom и т.д.)\r\n\r\n  const stopAutoScroll = useCallback(() => {\r\n    if (autoScrollIntervalRef.current) {\r\n      clearInterval(autoScrollIntervalRef.current);\r\n      autoScrollIntervalRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const startAutoScroll = useCallback(\r\n    (direction, speed = 1) => {\r\n      stopAutoScroll();\r\n      autoScrollIntervalRef.current = setInterval(() => {\r\n        if (timelineScrollRef.current) {\r\n          const scrollAmount = 15 * speed;\r\n          const currentScrollLeft = timelineScrollRef.current.scrollLeft;\r\n          const maxScroll =\r\n            timelineScrollRef.current.scrollWidth -\r\n            timelineScrollRef.current.clientWidth;\r\n\r\n          if (direction === \"left\" && currentScrollLeft > 0) {\r\n            timelineScrollRef.current.scrollLeft = Math.max(\r\n              0,\r\n              currentScrollLeft - scrollAmount\r\n            );\r\n          } else if (direction === \"right\" && currentScrollLeft < maxScroll) {\r\n            timelineScrollRef.current.scrollLeft = Math.min(\r\n              maxScroll,\r\n              currentScrollLeft + scrollAmount\r\n            );\r\n          }\r\n        }\r\n      }, 16);\r\n    },\r\n    [stopAutoScroll]\r\n  );\r\n\r\n  const checkAutoScroll = useCallback(\r\n    (clientX) => {\r\n      if (!timelineScrollRef.current) return;\r\n\r\n      const rect = timelineScrollRef.current.getBoundingClientRect();\r\n      const scrollZoneWidth = 120;\r\n      const relativeX = clientX - rect.left;\r\n\r\n      if (\r\n        relativeX < scrollZoneWidth &&\r\n        timelineScrollRef.current.scrollLeft > 0\r\n      ) {\r\n        const speed = ((scrollZoneWidth - relativeX) / scrollZoneWidth) * 3;\r\n        startAutoScroll(\"left\", speed);\r\n      } else if (relativeX > rect.width - scrollZoneWidth) {\r\n        const maxScroll =\r\n          timelineScrollRef.current.scrollWidth -\r\n          timelineScrollRef.current.clientWidth;\r\n        if (timelineScrollRef.current.scrollLeft < maxScroll) {\r\n          const speed =\r\n            ((relativeX - (rect.width - scrollZoneWidth)) / scrollZoneWidth) *\r\n            3;\r\n          startAutoScroll(\"right\", speed);\r\n        }\r\n      } else {\r\n        stopAutoScroll();\r\n      }\r\n    },\r\n    [startAutoScroll, stopAutoScroll]\r\n  );\r\n\r\n  // Утилиты\r\n  const getTimelineWidth = () => {\r\n    const baseWidth = videoDuration * 50 * timelineZoom;\r\n    return Math.max(baseWidth, 2000);\r\n  };\r\n\r\n  const getPixelsPerSecond = () => {\r\n    return 50 * timelineZoom;\r\n  };\r\n\r\n  const getTrackColor = (trackType) => {\r\n    switch (trackType) {\r\n      case \"overlay\":\r\n        return \"bg-purple-500 border-purple-400\";\r\n      case \"main\":\r\n        return \"bg-blue-500 border-blue-400\";\r\n      case \"audio\":\r\n        return \"bg-green-500 border-green-400\";\r\n      default:\r\n        return \"bg-gray-500 border-gray-400\";\r\n    }\r\n  };\r\n\r\n  const getTimelineItemStyle = (item) => {\r\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\r\n    const trackIndex = allTracks.findIndex(\r\n      (track) => track.id === item.trackId\r\n    );\r\n    const pixelsPerSecond = getPixelsPerSecond();\r\n\r\n    return {\r\n      left: `${item.startTime * pixelsPerSecond}px`,\r\n      width: `${item.duration * pixelsPerSecond}px`,\r\n      top: `${trackIndex * 60 + 10}px`,\r\n    };\r\n  };\r\n\r\n  const getDropPreviewStyle = () => {\r\n    if (!dropPreview) return {};\r\n\r\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\r\n    const trackIndex = allTracks.findIndex(\r\n      (track) => track.id === dropPreview.trackId\r\n    );\r\n    const pixelsPerSecond = getPixelsPerSecond();\r\n\r\n    return {\r\n      left: `${dropPreview.time * pixelsPerSecond}px`,\r\n      width: `${dropPreview.duration * pixelsPerSecond}px`,\r\n      top: `${trackIndex * 60 + 10}px`,\r\n    };\r\n  };\r\n\r\n  // Zoom функции\r\n  const zoomIn = () => setTimelineZoom((prev) => Math.min(20, prev * 1.5));\r\n  const zoomOut = () => setTimelineZoom((prev) => Math.max(0.1, prev / 1.5));\r\n  const resetZoom = () => setTimelineZoom(1);\r\n\r\n  // Функции для добавления треков\r\n  const addOverlayTrack = () => {\r\n    const newTrackId = `overlay-${Date.now()}`;\r\n    setTracks((prev) => ({\r\n      ...prev,\r\n      overlays: [\r\n        ...prev.overlays,\r\n        {\r\n          id: newTrackId,\r\n          name: `Overlay ${prev.overlays.length + 1}`,\r\n          type: \"overlay\",\r\n        },\r\n      ],\r\n    }));\r\n  };\r\n\r\n  const addAudioTrack = () => {\r\n    const newTrackId = `audio-${Date.now()}`;\r\n    setTracks((prev) => ({\r\n      ...prev,\r\n      audio: [\r\n        ...prev.audio,\r\n        {\r\n          id: newTrackId,\r\n          name: `Audio ${prev.audio.length + 1}`,\r\n          type: \"audio\",\r\n        },\r\n      ],\r\n    }));\r\n  };\r\n\r\n  // Остальные обработчики событий остаются такими же...\r\n  // (handleTimelineClick, handleDragOver, handleDrop и т.д.)\r\n\r\n  return (\r\n    <>\r\n      <div\r\n        className={`h-80 bg-white rounded-2xl shadow-sm border-2 transition-all duration-200 overflow-hidden flex flex-col flex-shrink-0 ${\r\n          isDragging || isTimelineDragging || isResizing\r\n            ? \"border-blue-400 bg-blue-50/20\"\r\n            : \"border-gray-200\"\r\n        }`}\r\n      >\r\n        <TimelineHeader\r\n          draggedItem={draggedItem}\r\n          isDragging={isDragging}\r\n          isTimelineDragging={isTimelineDragging}\r\n          isResizing={isResizing}\r\n          dropPreview={dropPreview}\r\n          draggedTimelineItem={draggedTimelineItem}\r\n          resizeItem={resizeItem}\r\n          resizeHandle={resizeHandle}\r\n          copiedItem={copiedItem}\r\n          timelineZoom={timelineZoom}\r\n          selectedTimelineItem={selectedTimelineItem}\r\n          onOpenExportModal={openExportModal} // Передаем функцию открытия модалки\r\n          addOverlayTrack={addOverlayTrack}\r\n          addAudioTrack={addAudioTrack}\r\n          addToTimelineAtCurrentTime={() => {}} // implement\r\n          splitTimelineItem={splitTimelineItem}\r\n          copyTimelineItem={copyTimelineItem}\r\n          pasteTimelineItem={pasteTimelineItem}\r\n          deleteSelectedItem={deleteSelectedItem}\r\n          zoomIn={zoomIn}\r\n          zoomOut={zoomOut}\r\n          resetZoom={resetZoom}\r\n        />\r\n\r\n        <div className=\"flex-1 flex min-h-0\">\r\n          <TrackLabels\r\n            tracks={tracks}\r\n            trackLabelsRef={trackLabelsRef}\r\n            onScroll={() => {}} // implement\r\n          />\r\n\r\n          <TimelineCanvas\r\n            timelineRef={timelineRef}\r\n            timelineScrollRef={timelineScrollRef}\r\n            tracks={tracks}\r\n            timelineItems={timelineItems}\r\n            selectedTimelineItem={selectedTimelineItem}\r\n            draggedTimelineItem={draggedTimelineItem}\r\n            copiedItem={copiedItem}\r\n            dropPreview={dropPreview}\r\n            getTimelineWidth={getTimelineWidth}\r\n            getPixelsPerSecond={getPixelsPerSecond}\r\n            getTrackColor={getTrackColor}\r\n            getTimelineItemStyle={getTimelineItemStyle}\r\n            getDropPreviewStyle={getDropPreviewStyle}\r\n            videoDuration={videoDuration}\r\n            timelineZoom={timelineZoom}\r\n            currentTime={currentTime}\r\n            formatTime={formatTime}\r\n            onScroll={() => {}} // implement\r\n            onDragOver={() => {}} // implement\r\n            onDrop={() => {}} // implement\r\n            onDragLeave={() => {}} // implement\r\n            onClick={() => {}} // implement\r\n            onDoubleClick={() => {}} // implement\r\n            onTimelineItemSelect={setSelectedTimelineItem}\r\n            onTimelineItemDragStart={() => {}} // implement\r\n            onTimelineItemDragEnd={() => {}} // implement\r\n            onResizeStart={() => {}} // implement\r\n          />\r\n        </div>\r\n      </div>\r\n\r\n      {/* Модальное окно экспорта */}\r\n      <VideoExportModal\r\n        isOpen={isExportModalOpen}\r\n        onClose={closeExportModal}\r\n        timelineItems={prepareExportData()}\r\n        tracks={tracks}\r\n        videoDuration={videoDuration}\r\n        onExport={handleExportStart}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\n// Улучшенный VideoExporter класс с поддержкой WebCodecs API\r\nclass VideoExporter {\r\n  constructor({ timelineItems, tracks, videoDuration, settings }) {\r\n    this.timelineItems = timelineItems;\r\n    this.tracks = tracks;\r\n    this.videoDuration = videoDuration;\r\n    this.settings = settings;\r\n    \r\n    // Проверяем поддержку WebCodecs API\r\n    this.useWebCodecs = 'VideoEncoder' in window && 'VideoFrame' in window;\r\n    \r\n    this.canvas = document.createElement('canvas');\r\n    this.ctx = this.canvas.getContext('2d');\r\n    \r\n    // Установка размеров canvas\r\n    const [width, height] = settings.resolution.split('x').map(Number);\r\n    this.canvas.width = width;\r\n    this.canvas.height = height;\r\n  }\r\n\r\n  async render() {\r\n    if (this.useWebCodecs) {\r\n      return await this.renderWithWebCodecs();\r\n    } else {\r\n      return await this.renderWithMediaRecorder();\r\n    }\r\n  }\r\n\r\n  async renderWithWebCodecs() {\r\n    // Современный способ с WebCodecs API (Chrome 94+)\r\n    const chunks = [];\r\n    \r\n    const videoEncoder = new VideoEncoder({\r\n      output: (chunk) => {\r\n        chunks.push(chunk);\r\n      },\r\n      error: (error) => {\r\n        console.error('Video encoding error:', error);\r\n      }\r\n    });\r\n\r\n    videoEncoder.configure({\r\n      codec: 'avc1.42001E', // H.264 Baseline\r\n      width: this.canvas.width,\r\n      height: this.canvas.height,\r\n      bitrate: this.settings.bitrate * 1000,\r\n      framerate: this.settings.fps\r\n    });\r\n\r\n    const frameCount = Math.ceil(this.videoDuration * this.settings.fps);\r\n    const frameDuration = 1000000 / this.settings.fps; // в микросекундах\r\n\r\n    for (let frame = 0; frame < frameCount; frame++) {\r\n      const currentTime = frame / this.settings.fps;\r\n      await this.renderFrame(currentTime);\r\n      \r\n      const videoFrame = new VideoFrame(this.canvas, {\r\n        timestamp: frame * frameDuration\r\n      });\r\n      \r\n      videoEncoder.encode(videoFrame, { keyFrame: frame % 30 === 0 });\r\n      videoFrame.close();\r\n    }\r\n\r\n    await videoEncoder.flush();\r\n    videoEncoder.close();\r\n\r\n    // Создаем MP4 контейнер (упрощенная версия)\r\n    return new Blob(chunks, { type: `video/${this.settings.format}` });\r\n  }\r\n\r\n  async renderWithMediaRecorder() {\r\n    // Старый способ с MediaRecorder (больше совместимости)\r\n    const stream = this.canvas.captureStream(this.settings.fps);\r\n    \r\n    const options = {\r\n      mimeType: this.getMimeType(),\r\n      videoBitsPerSecond: this.settings.bitrate * 1000\r\n    };\r\n\r\n    const mediaRecorder = new MediaRecorder(stream, options);\r\n    const chunks = [];\r\n\r\n    mediaRecorder.ondataavailable = (event) => {\r\n      if (event.data.size > 0) {\r\n        chunks.push(event.data);\r\n      }\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      mediaRecorder.onstop = () => {\r\n        const blob = new Blob(chunks, { type: `video/${this.settings.format}` });\r\n        resolve(blob);\r\n      };\r\n\r\n      mediaRecorder.onerror = reject;\r\n\r\n      mediaRecorder.start();\r\n      \r\n      this.renderFrames().then(() => {\r\n        mediaRecorder.stop();\r\n      }).catch(reject);\r\n    });\r\n  }\r\n\r\n  getMimeType() {\r\n    const formats = {\r\n      mp4: 'video/mp4;codecs=h264',\r\n      webm: 'video/webm;codecs=vp9',\r\n      mov: 'video/mp4;codecs=h264'\r\n    };\r\n    \r\n    return formats[this.settings.format] || formats.mp4;\r\n  }\r\n\r\n  async renderFrames() {\r\n    const frameCount = Math.ceil(this.videoDuration * this.settings.fps);\r\n    const frameDuration = 1 / this.settings.fps;\r\n\r\n    for (let frame = 0; frame < frameCount; frame++) {\r\n      const currentTime = frame * frameDuration;\r\n      await this.renderFrame(currentTime);\r\n      \r\n      // Ждем следующий кадр\r\n      await new Promise(resolve => requestAnimationFrame(resolve));\r\n    }\r\n  }\r\n\r\n  async renderFrame(currentTime) {\r\n    // Очищаем canvas черным фоном\r\n    this.ctx.fillStyle = '#000000';\r\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n    // Сортируем элементы по слоям\r\n    const sortedItems = [...this.timelineItems].sort((a, b) => {\r\n      const order = { main: 1, audio: 2, overlay: 3 };\r\n      return order[a.trackType] - order[b.trackType];\r\n    });\r\n\r\n    // Рендерим каждый активный элемент\r\n    for (const item of sortedItems) {\r\n      if (this.isItemActiveAtTime(item, currentTime)) {\r\n        const relativeTime = currentTime - item.startTime;\r\n        await this.renderItem(item, relativeTime);\r\n      }\r\n    }\r\n  }\r\n\r\n  isItemActiveAtTime(item, currentTime) {\r\n    return currentTime >= item.startTime && \r\n           currentTime < item.startTime + item.duration;\r\n  }\r\n\r\n  async renderItem(item, relativeTime) {\r\n    switch (item.type) {\r\n      case 'video':\r\n        await this.renderVideo(item, relativeTime);\r\n        break;\r\n      case 'image':\r\n        await this.renderImage(item);\r\n        break;\r\n      case 'text':\r\n        await this.renderText(item);\r\n        break;\r\n      // Аудио не рендерится визуально\r\n    }\r\n  }\r\n\r\n  async renderVideo(item, relativeTime) {\r\n    if (!item.videoElement) return;\r\n    \r\n    try {\r\n      // Устанавливаем точное время\r\n      item.videoElement.currentTime = relativeTime;\r\n      \r\n      // Ждем загрузки кадра\r\n      await this.waitForVideoFrame(item.videoElement);\r\n      \r\n      // Рендерим с масштабированием\r\n      this.drawScaledMedia(item.videoElement);\r\n    } catch (error) {\r\n      console.warn('Ошибка рендеринга видео:', error);\r\n    }\r\n  }\r\n\r\n  async renderImage(item) {\r\n    if (!item.imageElement) return;\r\n    \r\n    try {\r\n      await this.waitForImageLoad(item.imageElement);\r\n      this.drawScaledMedia(item.imageElement);\r\n    } catch (error) {\r\n      console.warn('Ошибка рендеринга изображения:', error);\r\n    }\r\n  }\r\n\r\n  async renderText(item) {\r\n    if (!item.text) return;\r\n    \r\n    this.ctx.fillStyle = item.color || '#ffffff';\r\n    this.ctx.font = `${item.fontSize || 24}px ${item.fontFamily || 'Arial'}`;\r\n    this.ctx.textAlign = item.textAlign || 'center';\r\n    \r\n    const x = this.canvas.width / 2;\r\n    const y = this.canvas.height / 2;\r\n    \r\n    this.ctx.fillText(item.text, x, y);\r\n  }\r\n\r\n  drawScaledMedia(mediaElement) {\r\n    // Масштабируем медиа элемент под размер canvas\r\n    const canvasAspect = this.canvas.width / this.canvas.height;\r\n    const mediaAspect = mediaElement.videoWidth || mediaElement.naturalWidth || mediaElement.width;\r\n    const mediaHeight = mediaElement.videoHeight || mediaElement.naturalHeight || mediaElement.height;\r\n    const mediaAspectRatio = mediaAspect / mediaHeight;\r\n\r\n    let drawWidth, drawHeight, drawX, drawY;\r\n\r\n    if (mediaAspectRatio > canvasAspect) {\r\n      // Медиа шире canvas\r\n      drawWidth = this.canvas.width;\r\n      drawHeight = this.canvas.width / mediaAspectRatio;\r\n      drawX = 0;\r\n      drawY = (this.canvas.height - drawHeight) / 2;\r\n    } else {\r\n      // Медиа выше canvas\r\n      drawHeight = this.canvas.height;\r\n      drawWidth = this.canvas.height * mediaAspectRatio;\r\n      drawX = (this.canvas.width - drawWidth) / 2;\r\n      drawY = 0;\r\n    }\r\n\r\n    this.ctx.drawImage(mediaElement, drawX, drawY, drawWidth, drawHeight);\r\n  }\r\n\r\n  async waitForVideoFrame(videoElement) {\r\n    return new Promise((resolve) => {\r\n      const checkReady = () => {\r\n        if (videoElement.readyState >= 2) {\r\n          resolve();\r\n        } else {\r\n          requestAnimationFrame(checkReady);\r\n        }\r\n      };\r\n      checkReady();\r\n    });\r\n  }\r\n\r\n  async waitForImageLoad(imageElement) {\r\n    return new Promise((resolve, reject) => {\r\n      if (imageElement.complete) {\r\n        resolve();\r\n      } else {\r\n        imageElement.onload = resolve;\r\n        imageElement.onerror = reject;\r\n      }\r\n    });\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}