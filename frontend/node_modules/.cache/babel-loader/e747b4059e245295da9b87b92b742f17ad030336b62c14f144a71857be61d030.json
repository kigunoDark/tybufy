{"ast":null,"code":"var _jsxFileName = \"C:\\\\Scriptify\\\\ai-content-studio\\\\frontend\\\\src\\\\components\\\\Timeline\\\\Timeline.jsx\",\n  _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { TimelineCanvas } from \"./TimelineCanvas\";\nimport { TimelineHeader } from \"./TimelineHeader\";\nimport { TrackLabels } from \"./TrackLabels\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Timeline = ({\n  timelineItems,\n  setTimelineItems,\n  currentTime,\n  videoDuration,\n  setVideoDuration,\n  selectedTimelineItem,\n  setSelectedTimelineItem,\n  timelineZoom,\n  setTimelineZoom,\n  tracks,\n  setTracks,\n  draggedItem,\n  draggedTimelineItem,\n  setDraggedTimelineItem,\n  dropPreview,\n  setDropPreview,\n  setShowExportModal,\n  isDragging,\n  isTimelineDragging,\n  setIsTimelineDragging,\n  isResizing,\n  setIsResizing,\n  copiedItem,\n  formatTime,\n  seekTo,\n  splitTimelineItem,\n  copyTimelineItem,\n  pasteTimelineItem,\n  deleteSelectedItem,\n  addToTimeline,\n  insertWithRipple,\n  applyRippleEffect,\n  onSmartAddToTimeline\n}) => {\n  _s();\n  const timelineRef = useRef(null);\n  const timelineScrollRef = useRef(null);\n  const trackLabelsRef = useRef(null);\n  const autoScrollIntervalRef = useRef(null);\n  const [dragOffset, setDragOffset] = useState(0);\n  const [resizeHandle, setResizeHandle] = useState(null);\n  const [resizeItem, setResizeItem] = useState(null);\n  const [originalItemData, setOriginalItemData] = useState(null);\n  const handleVolumeChange = useCallback((itemId, volumeDecimal) => {\n    console.log(\"Volume changed:\", itemId, volumeDecimal);\n\n    // Обновляем состояние timeline items\n    setTimelineItems(items => items.map(item => item.id === itemId ? {\n      ...item,\n      volume: volumeDecimal\n    } // Сохраняем как десятичное значение 0-1\n    : item));\n\n    // Применяем volume к audio элементам\n    const audioElement = audioElementsRef.current.get(itemId);\n    if (audioElement) {\n      audioElement.volume = volumeDecimal * volume; // Умножаем на общий volume\n      console.log(`✅ Applied volume ${volumeDecimal * volume} to audio ${itemId}`);\n    }\n\n    // Применяем volume к video элементу (если это main video)\n    const item = timelineItems.find(t => t.id === itemId);\n    if (item && item.trackType === \"main\" && videoRef.current) {\n      videoRef.current.volume = volumeDecimal * volume;\n      console.log(`✅ Applied volume ${volumeDecimal * volume} to main video`);\n    }\n  }, [timelineItems, volume]);\n  const stopAutoScroll = useCallback(() => {\n    if (autoScrollIntervalRef.current) {\n      clearInterval(autoScrollIntervalRef.current);\n      autoScrollIntervalRef.current = null;\n    }\n  }, []);\n  const startAutoScroll = useCallback((direction, speed = 1) => {\n    stopAutoScroll();\n    autoScrollIntervalRef.current = setInterval(() => {\n      if (timelineScrollRef.current) {\n        const scrollAmount = 15 * speed;\n        const currentScrollLeft = timelineScrollRef.current.scrollLeft;\n        const maxScroll = timelineScrollRef.current.scrollWidth - timelineScrollRef.current.clientWidth;\n        if (direction === \"left\" && currentScrollLeft > 0) {\n          timelineScrollRef.current.scrollLeft = Math.max(0, currentScrollLeft - scrollAmount);\n        } else if (direction === \"right\" && currentScrollLeft < maxScroll) {\n          timelineScrollRef.current.scrollLeft = Math.min(maxScroll, currentScrollLeft + scrollAmount);\n        }\n      }\n    }, 16);\n  }, [stopAutoScroll]);\n  const checkAutoScroll = useCallback(clientX => {\n    if (!timelineScrollRef.current) return;\n    const rect = timelineScrollRef.current.getBoundingClientRect();\n    const scrollZoneWidth = 120;\n    const relativeX = clientX - rect.left;\n    if (relativeX < scrollZoneWidth && timelineScrollRef.current.scrollLeft > 0) {\n      const speed = (scrollZoneWidth - relativeX) / scrollZoneWidth * 3;\n      startAutoScroll(\"left\", speed);\n    } else if (relativeX > rect.width - scrollZoneWidth) {\n      const maxScroll = timelineScrollRef.current.scrollWidth - timelineScrollRef.current.clientWidth;\n      if (timelineScrollRef.current.scrollLeft < maxScroll) {\n        const speed = (relativeX - (rect.width - scrollZoneWidth)) / scrollZoneWidth * 3;\n        startAutoScroll(\"right\", speed);\n      }\n    } else {\n      stopAutoScroll();\n    }\n  }, [startAutoScroll, stopAutoScroll]);\n  const getTargetTrackForType = useCallback(mediaType => {\n    var _tracks$main, _tracks$audio, _tracks$overlays, _tracks$main2, _tracks$main2$;\n    switch (mediaType) {\n      case \"videos\":\n        const mainTrack = (_tracks$main = tracks.main) === null || _tracks$main === void 0 ? void 0 : _tracks$main[0];\n        return mainTrack === null || mainTrack === void 0 ? void 0 : mainTrack.id;\n      case \"audios\":\n        const audioTrack = (_tracks$audio = tracks.audio) === null || _tracks$audio === void 0 ? void 0 : _tracks$audio[0];\n        return audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.id;\n      case \"images\":\n        const overlayTrack = (_tracks$overlays = tracks.overlays) === null || _tracks$overlays === void 0 ? void 0 : _tracks$overlays[0];\n        return overlayTrack === null || overlayTrack === void 0 ? void 0 : overlayTrack.id;\n      default:\n        return (_tracks$main2 = tracks.main) === null || _tracks$main2 === void 0 ? void 0 : (_tracks$main2$ = _tracks$main2[0]) === null || _tracks$main2$ === void 0 ? void 0 : _tracks$main2$.id;\n    }\n  }, [tracks]);\n  const findBestPositionForItem = useCallback((item, targetTrackId) => {\n    const duration = item.duration || (item.type === \"image\" ? 5 : 10);\n    const itemsOnTrack = timelineItems.filter(timelineItem => timelineItem.trackId === targetTrackId).sort((a, b) => a.startTime - b.startTime);\n    if (itemsOnTrack.length === 0) {\n      return currentTime;\n    }\n    const hasSpaceAtCurrentTime = !itemsOnTrack.some(existingItem => {\n      const existingStart = existingItem.startTime;\n      const existingEnd = existingItem.startTime + existingItem.duration;\n      const newStart = currentTime;\n      const newEnd = currentTime + duration;\n      return !(newEnd <= existingStart || newStart >= existingEnd);\n    });\n    if (hasSpaceAtCurrentTime) {\n      return currentTime;\n    }\n    const lastItem = itemsOnTrack[itemsOnTrack.length - 1];\n    return lastItem.startTime + lastItem.duration;\n  }, [timelineItems, currentTime]);\n\n  // Утилиты\n  const getTimelineWidth = () => {\n    const baseWidth = videoDuration * 50 * timelineZoom;\n    return Math.max(baseWidth, 2000);\n  };\n  const getPixelsPerSecond = () => {\n    return 50 * timelineZoom;\n  };\n  const getTrackColor = trackType => {\n    switch (trackType) {\n      case \"overlay\":\n        return \"bg-purple-500 border-purple-400\";\n      case \"main\":\n        return \"bg-blue-500 border-blue-400\";\n      case \"audio\":\n        return \"bg-green-500 border-green-400\";\n      default:\n        return \"bg-gray-500 border-gray-400\";\n    }\n  };\n  const getTimelineItemStyle = item => {\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\n    const trackIndex = allTracks.findIndex(track => track.id === item.trackId);\n    const pixelsPerSecond = getPixelsPerSecond();\n    return {\n      left: `${item.startTime * pixelsPerSecond}px`,\n      width: `${item.duration * pixelsPerSecond}px`,\n      top: `${trackIndex * 60 + 10}px`\n    };\n  };\n  const getDropPreviewStyle = () => {\n    if (!dropPreview) return {};\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\n    const trackIndex = allTracks.findIndex(track => track.id === dropPreview.trackId);\n    const pixelsPerSecond = getPixelsPerSecond();\n    return {\n      left: `${dropPreview.time * pixelsPerSecond}px`,\n      width: `${dropPreview.duration * pixelsPerSecond}px`,\n      top: `${trackIndex * 60 + 10}px`\n    };\n  };\n  const zoomIn = () => setTimelineZoom(prev => Math.min(20, prev * 1.5));\n  const zoomOut = () => setTimelineZoom(prev => Math.max(0.1, prev / 1.5));\n  const resetZoom = () => setTimelineZoom(1);\n  const addOverlayTrack = () => {\n    const newTrackId = `overlay-${Date.now()}`;\n    setTracks(prev => ({\n      ...prev,\n      overlays: [...prev.overlays, {\n        id: newTrackId,\n        name: `Overlay ${prev.overlays.length + 1}`,\n        type: \"overlay\"\n      }]\n    }));\n  };\n  const addAudioTrack = () => {\n    const newTrackId = `audio-${Date.now()}`;\n    setTracks(prev => ({\n      ...prev,\n      audio: [...prev.audio, {\n        id: newTrackId,\n        name: `Audio ${prev.audio.length + 1}`,\n        type: \"audio\"\n      }]\n    }));\n  };\n  const addToTimelineAtCurrentTime = useCallback(() => {\n    if (!draggedItem) return;\n    const targetTrackId = getTargetTrackForType(draggedItem.type);\n    if (!targetTrackId) return;\n    const bestPosition = findBestPositionForItem(draggedItem, targetTrackId);\n    addToTimeline(draggedItem, bestPosition, targetTrackId);\n  }, [draggedItem, getTargetTrackForType, findBestPositionForItem, addToTimeline]);\n  const handleResizeStart = useCallback((e, item, handle) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsResizing(true);\n    setResizeHandle(handle);\n    setResizeItem(item);\n    setOriginalItemData({\n      startTime: item.startTime,\n      duration: item.duration\n    });\n    setIsTimelineDragging(false);\n    setDraggedTimelineItem(null);\n  }, [setIsResizing, setIsTimelineDragging, setDraggedTimelineItem]);\n  const handleResizeEnd = useCallback(() => {\n    setIsResizing(false);\n    setResizeHandle(null);\n    setResizeItem(null);\n    setOriginalItemData(null);\n    stopAutoScroll();\n  }, [setIsResizing, stopAutoScroll]);\n  const handleTimelineItemDragStart = (e, timelineItem) => {\n    if (isResizing) {\n      e.preventDefault();\n      return;\n    }\n    e.stopPropagation();\n    setDraggedTimelineItem(timelineItem);\n    setIsTimelineDragging(true);\n    const rect = timelineScrollRef.current.getBoundingClientRect();\n    const itemRect = e.target.getBoundingClientRect();\n    setDragOffset(e.clientX - itemRect.left + timelineScrollRef.current.scrollLeft);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setData(\"text/plain\", \"\");\n  };\n  const handleTimelineItemDragEnd = () => {\n    setDraggedTimelineItem(null);\n    setDropPreview(null);\n    setIsTimelineDragging(false);\n    setDragOffset(0);\n    stopAutoScroll();\n  };\n  const handleTimelineClick = e => {\n    if (isDragging || isTimelineDragging || isResizing) return;\n    const rect = timelineScrollRef.current.getBoundingClientRect();\n    const clickX = e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\n    const pixelsPerSecond = getPixelsPerSecond();\n    const clickTime = clickX / pixelsPerSecond;\n    seekTo(clickTime);\n  };\n  const handleTimelineDoubleClick = useCallback(e => {\n    if (isDragging || isTimelineDragging || isResizing || !draggedItem) return;\n    const rect = timelineScrollRef.current.getBoundingClientRect();\n    const clickX = e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\n    const pixelsPerSecond = getPixelsPerSecond();\n    const clickTime = clickX / pixelsPerSecond;\n    const targetTrackId = getTargetTrackForType(draggedItem.type);\n    if (targetTrackId) {\n      addToTimeline(draggedItem, clickTime, targetTrackId);\n    }\n  }, [isDragging, isTimelineDragging, isResizing, draggedItem, getTargetTrackForType, addToTimeline]);\n  const handleDragOver = e => {\n    if (!draggedItem && !draggedTimelineItem) return;\n    e.preventDefault();\n    e.dataTransfer.dropEffect = draggedItem ? \"copy\" : \"move\";\n    if (draggedTimelineItem || isResizing) {\n      checkAutoScroll(e.clientX);\n    }\n    const timelineRect = timelineScrollRef.current.getBoundingClientRect();\n    const dragX = e.clientX - timelineRect.left + timelineScrollRef.current.scrollLeft - (draggedTimelineItem ? dragOffset : 0);\n    const pixelsPerSecond = getPixelsPerSecond();\n    const dropTime = Math.max(0, dragX / pixelsPerSecond);\n    const dragY = e.clientY - timelineRect.top + timelineScrollRef.current.scrollTop;\n    const trackHeight = 60;\n    const timeRulerHeight = 48;\n    const relativeY = dragY - timeRulerHeight;\n    const trackIndex = Math.floor(relativeY / trackHeight);\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\n    const targetTrack = allTracks[trackIndex];\n    if (draggedItem && targetTrack) {\n      const duration = draggedItem.duration || (draggedItem.type === \"image\" ? 5 : 10);\n      const insertResult = insertWithRipple(targetTrack.id, dropTime, duration);\n      setDropPreview({\n        time: insertResult.time,\n        duration: duration,\n        trackId: targetTrack.id,\n        trackType: targetTrack.type,\n        isValid: true,\n        shouldRipple: insertResult.shouldRipple,\n        affectedItems: insertResult.affectedItems || []\n      });\n    } else if (draggedTimelineItem && targetTrack) {\n      const insertResult = insertWithRipple(targetTrack.id, dropTime, draggedTimelineItem.duration, draggedTimelineItem.id);\n      setDropPreview({\n        time: insertResult.time,\n        duration: draggedTimelineItem.duration,\n        trackId: targetTrack.id,\n        trackType: targetTrack.type,\n        isValid: true,\n        shouldRipple: insertResult.shouldRipple,\n        affectedItems: insertResult.affectedItems || []\n      });\n    }\n  };\n  const handleDrop = e => {\n    e.preventDefault();\n    stopAutoScroll();\n    if (!dropPreview && draggedItem) {\n      const targetTrackId = getTargetTrackForType(draggedItem.type);\n      if (targetTrackId) {\n        const bestPosition = findBestPositionForItem(draggedItem, targetTrackId);\n        addToTimeline(draggedItem, bestPosition, targetTrackId);\n      }\n      setDropPreview(null);\n      setIsTimelineDragging(false);\n      return;\n    }\n    if (!draggedItem && !draggedTimelineItem || !dropPreview) return;\n    if (dropPreview.isValid) {\n      if (draggedItem) {\n        var _dropPreview$affected;\n        if (dropPreview.shouldRipple && ((_dropPreview$affected = dropPreview.affectedItems) === null || _dropPreview$affected === void 0 ? void 0 : _dropPreview$affected.length) > 0) {\n          applyRippleEffect(dropPreview.affectedItems, dropPreview.duration);\n        }\n        addToTimeline(draggedItem, dropPreview.time, dropPreview.trackId);\n      } else if (draggedTimelineItem) {\n        var _dropPreview$affected2;\n        if (dropPreview.shouldRipple && ((_dropPreview$affected2 = dropPreview.affectedItems) === null || _dropPreview$affected2 === void 0 ? void 0 : _dropPreview$affected2.length) > 0) {\n          applyRippleEffect(dropPreview.affectedItems, draggedTimelineItem.duration);\n        }\n        setTimelineItems(prev => prev.map(item => item.id === draggedTimelineItem.id ? {\n          ...item,\n          startTime: dropPreview.time,\n          trackId: dropPreview.trackId,\n          trackType: dropPreview.trackType\n        } : item));\n        const newEndTime = dropPreview.time + draggedTimelineItem.duration;\n        if (newEndTime > videoDuration) {\n          setVideoDuration(newEndTime + 10);\n        }\n      }\n    }\n    setDropPreview(null);\n    setIsTimelineDragging(false);\n  };\n  const handleDragLeave = e => {\n    var _timelineRef$current;\n    if (!((_timelineRef$current = timelineRef.current) !== null && _timelineRef$current !== void 0 && _timelineRef$current.contains(e.relatedTarget))) {\n      setDropPreview(null);\n      stopAutoScroll();\n    }\n  };\n  const handleTrackAreaScroll = e => {\n    if (trackLabelsRef.current) {\n      trackLabelsRef.current.scrollTop = e.target.scrollTop;\n    }\n  };\n  const handleTrackLabelsScroll = e => {\n    if (timelineScrollRef.current) {\n      timelineScrollRef.current.scrollTop = e.target.scrollTop;\n    }\n  };\n  const handleWheel = useCallback(e => {\n    if (e.ctrlKey) {\n      e.preventDefault();\n      if (!timelineScrollRef.current) return;\n      const rect = timelineScrollRef.current.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\n      const currentPixelsPerSecond = 50 * timelineZoom;\n      const timeAtMouse = mouseX / currentPixelsPerSecond;\n      const zoomDirection = e.deltaY < 0 ? 1 : -1;\n      const zoomStep = 1.2;\n      setTimelineZoom(prevZoom => {\n        let newZoom;\n        if (zoomDirection > 0) {\n          newZoom = Math.min(20, prevZoom * zoomStep);\n        } else {\n          newZoom = Math.max(0.1, prevZoom / zoomStep);\n        }\n        requestAnimationFrame(() => {\n          if (timelineScrollRef.current) {\n            const newPixelsPerSecond = 50 * newZoom;\n            const newMouseX = timeAtMouse * newPixelsPerSecond;\n            const targetScrollLeft = newMouseX - (e.clientX - rect.left);\n            timelineScrollRef.current.scrollLeft = Math.max(0, targetScrollLeft);\n          }\n        });\n        return newZoom;\n      });\n    } else if (e.shiftKey) {\n      e.preventDefault();\n      if (timelineScrollRef.current) {\n        const scrollAmount = e.deltaY * 2;\n        timelineScrollRef.current.scrollLeft += scrollAmount;\n      }\n    }\n  }, [timelineZoom, setTimelineZoom]);\n  const smartAddToTimeline = useCallback((item, specifiedTime = null, specifiedTrackId = null) => {\n    if (specifiedTime !== null && specifiedTrackId !== null) {\n      addToTimeline(item, specifiedTime, specifiedTrackId);\n      return;\n    }\n    const targetTrackId = specifiedTrackId || getTargetTrackForType(item.type);\n    if (!targetTrackId) {\n      console.error(`Не найдена подходящая дорожка для типа ${item.type}`);\n      return;\n    }\n    const bestPosition = specifiedTime !== null ? specifiedTime : findBestPositionForItem(item, targetTrackId);\n    addToTimeline(item, bestPosition, targetTrackId);\n  }, [addToTimeline, getTargetTrackForType, findBestPositionForItem]);\n  useEffect(() => {\n    const handleMouseMove = e => {\n      if (!isResizing || !resizeItem || !timelineScrollRef.current) return;\n      checkAutoScroll(e.clientX);\n      const rect = timelineScrollRef.current.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\n      const pixelsPerSecond = getPixelsPerSecond();\n      const newTime = mouseX / pixelsPerSecond;\n      setTimelineItems(prev => prev.map(item => {\n        if (item.id !== resizeItem.id) return item;\n        const minDuration = 0.1;\n        if (resizeHandle === \"left\") {\n          const rightEdge = originalItemData.startTime + originalItemData.duration;\n          const newStartTime = Math.max(0, Math.min(rightEdge - minDuration, newTime));\n          const newDuration = rightEdge - newStartTime;\n          return {\n            ...item,\n            startTime: newStartTime,\n            duration: newDuration\n          };\n        } else if (resizeHandle === \"right\") {\n          const leftEdge = originalItemData.startTime;\n          const newEndTime = Math.max(leftEdge + minDuration, newTime);\n          const newDuration = newEndTime - leftEdge;\n          return {\n            ...item,\n            duration: newDuration\n          };\n        }\n        return item;\n      }));\n    };\n    const handleMouseUp = () => {\n      if (isResizing) {\n        handleResizeEnd();\n      }\n    };\n    if (isResizing) {\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n    }\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [isResizing, resizeItem, resizeHandle, originalItemData, getPixelsPerSecond, checkAutoScroll, handleResizeEnd, setTimelineItems]);\n  useEffect(() => {\n    if (onSmartAddToTimeline) {\n      onSmartAddToTimeline(smartAddToTimeline);\n    }\n  }, [onSmartAddToTimeline, smartAddToTimeline]);\n  useEffect(() => {\n    return () => {\n      stopAutoScroll();\n    };\n  }, [stopAutoScroll]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `h-80 bg-white rounded-2xl shadow-sm border-2 transition-all duration-200 overflow-hidden flex flex-col flex-shrink-0 ${isDragging || isTimelineDragging || isResizing ? \"border-blue-400 bg-blue-50/20\" : \"border-gray-200\"}`,\n    onWheel: handleWheel,\n    children: [/*#__PURE__*/_jsxDEV(TimelineHeader, {\n      draggedItem: draggedItem,\n      isDragging: isDragging,\n      isTimelineDragging: isTimelineDragging,\n      isResizing: isResizing,\n      setShowExportModal: setShowExportModal,\n      dropPreview: dropPreview,\n      draggedTimelineItem: draggedTimelineItem,\n      resizeItem: resizeItem,\n      resizeHandle: resizeHandle,\n      copiedItem: copiedItem,\n      timelineZoom: timelineZoom,\n      selectedTimelineItem: selectedTimelineItem,\n      addOverlayTrack: addOverlayTrack,\n      addAudioTrack: addAudioTrack,\n      addToTimelineAtCurrentTime: addToTimelineAtCurrentTime,\n      splitTimelineItem: splitTimelineItem,\n      copyTimelineItem: copyTimelineItem,\n      pasteTimelineItem: pasteTimelineItem,\n      deleteSelectedItem: deleteSelectedItem,\n      zoomIn: zoomIn,\n      zoomOut: zoomOut,\n      resetZoom: resetZoom\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 701,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex-1 flex min-h-0\",\n      children: [/*#__PURE__*/_jsxDEV(TrackLabels, {\n        tracks: tracks,\n        trackLabelsRef: trackLabelsRef,\n        onScroll: handleTrackLabelsScroll\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 727,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(TimelineCanvas, {\n        timelineRef: timelineRef,\n        timelineScrollRef: timelineScrollRef,\n        tracks: tracks,\n        onVolumeChange: handleVolumeChange,\n        showVolumeControls: true,\n        timelineItems: timelineItems,\n        selectedTimelineItem: selectedTimelineItem,\n        draggedTimelineItem: draggedTimelineItem,\n        copiedItem: copiedItem,\n        dropPreview: dropPreview,\n        getTimelineWidth: getTimelineWidth,\n        getPixelsPerSecond: getPixelsPerSecond,\n        getTrackColor: getTrackColor,\n        getTimelineItemStyle: getTimelineItemStyle,\n        getDropPreviewStyle: getDropPreviewStyle,\n        videoDuration: videoDuration,\n        timelineZoom: timelineZoom,\n        currentTime: currentTime,\n        formatTime: formatTime,\n        onScroll: handleTrackAreaScroll,\n        onDragOver: handleDragOver,\n        onDrop: handleDrop,\n        onDragLeave: handleDragLeave,\n        onClick: handleTimelineClick,\n        onDoubleClick: handleTimelineDoubleClick,\n        onTimelineItemSelect: setSelectedTimelineItem,\n        onTimelineItemDragStart: handleTimelineItemDragStart,\n        onTimelineItemDragEnd: handleTimelineItemDragEnd,\n        onResizeStart: handleResizeStart\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 733,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 726,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 693,\n    columnNumber: 5\n  }, this);\n};\n_s(Timeline, \"65/0NJzSzmANYRtVi8iWcjdknsM=\");\n_c = Timeline;\nvar _c;\n$RefreshReg$(_c, \"Timeline\");","map":{"version":3,"names":["useState","useRef","useEffect","useCallback","TimelineCanvas","TimelineHeader","TrackLabels","jsxDEV","_jsxDEV","Timeline","timelineItems","setTimelineItems","currentTime","videoDuration","setVideoDuration","selectedTimelineItem","setSelectedTimelineItem","timelineZoom","setTimelineZoom","tracks","setTracks","draggedItem","draggedTimelineItem","setDraggedTimelineItem","dropPreview","setDropPreview","setShowExportModal","isDragging","isTimelineDragging","setIsTimelineDragging","isResizing","setIsResizing","copiedItem","formatTime","seekTo","splitTimelineItem","copyTimelineItem","pasteTimelineItem","deleteSelectedItem","addToTimeline","insertWithRipple","applyRippleEffect","onSmartAddToTimeline","_s","timelineRef","timelineScrollRef","trackLabelsRef","autoScrollIntervalRef","dragOffset","setDragOffset","resizeHandle","setResizeHandle","resizeItem","setResizeItem","originalItemData","setOriginalItemData","handleVolumeChange","itemId","volumeDecimal","console","log","items","map","item","id","volume","audioElement","audioElementsRef","current","get","find","t","trackType","videoRef","stopAutoScroll","clearInterval","startAutoScroll","direction","speed","setInterval","scrollAmount","currentScrollLeft","scrollLeft","maxScroll","scrollWidth","clientWidth","Math","max","min","checkAutoScroll","clientX","rect","getBoundingClientRect","scrollZoneWidth","relativeX","left","width","getTargetTrackForType","mediaType","_tracks$main","_tracks$audio","_tracks$overlays","_tracks$main2","_tracks$main2$","mainTrack","main","audioTrack","audio","overlayTrack","overlays","findBestPositionForItem","targetTrackId","duration","type","itemsOnTrack","filter","timelineItem","trackId","sort","a","b","startTime","length","hasSpaceAtCurrentTime","some","existingItem","existingStart","existingEnd","newStart","newEnd","lastItem","getTimelineWidth","baseWidth","getPixelsPerSecond","getTrackColor","getTimelineItemStyle","allTracks","trackIndex","findIndex","track","pixelsPerSecond","top","getDropPreviewStyle","time","zoomIn","prev","zoomOut","resetZoom","addOverlayTrack","newTrackId","Date","now","name","addAudioTrack","addToTimelineAtCurrentTime","bestPosition","handleResizeStart","e","handle","preventDefault","stopPropagation","handleResizeEnd","handleTimelineItemDragStart","itemRect","target","dataTransfer","effectAllowed","setData","handleTimelineItemDragEnd","handleTimelineClick","clickX","clickTime","handleTimelineDoubleClick","handleDragOver","dropEffect","timelineRect","dragX","dropTime","dragY","clientY","scrollTop","trackHeight","timeRulerHeight","relativeY","floor","targetTrack","insertResult","isValid","shouldRipple","affectedItems","handleDrop","_dropPreview$affected","_dropPreview$affected2","newEndTime","handleDragLeave","_timelineRef$current","contains","relatedTarget","handleTrackAreaScroll","handleTrackLabelsScroll","handleWheel","ctrlKey","mouseX","currentPixelsPerSecond","timeAtMouse","zoomDirection","deltaY","zoomStep","prevZoom","newZoom","requestAnimationFrame","newPixelsPerSecond","newMouseX","targetScrollLeft","shiftKey","smartAddToTimeline","specifiedTime","specifiedTrackId","error","handleMouseMove","newTime","minDuration","rightEdge","newStartTime","newDuration","leftEdge","handleMouseUp","document","addEventListener","removeEventListener","className","onWheel","children","fileName","_jsxFileName","lineNumber","columnNumber","onScroll","onVolumeChange","showVolumeControls","onDragOver","onDrop","onDragLeave","onClick","onDoubleClick","onTimelineItemSelect","onTimelineItemDragStart","onTimelineItemDragEnd","onResizeStart","_c","$RefreshReg$"],"sources":["C:/Scriptify/ai-content-studio/frontend/src/components/Timeline/Timeline.jsx"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from \"react\";\r\nimport { TimelineCanvas } from \"./TimelineCanvas\";\r\nimport { TimelineHeader } from \"./TimelineHeader\";\r\n\r\nimport { TrackLabels } from \"./TrackLabels\";\r\nexport const Timeline = ({\r\n  timelineItems,\r\n  setTimelineItems,\r\n  currentTime,\r\n  videoDuration,\r\n  setVideoDuration,\r\n  selectedTimelineItem,\r\n  setSelectedTimelineItem,\r\n  timelineZoom,\r\n  setTimelineZoom,\r\n  tracks,\r\n  setTracks,\r\n  draggedItem,\r\n  draggedTimelineItem,\r\n  setDraggedTimelineItem,\r\n  dropPreview,\r\n  setDropPreview,\r\n  setShowExportModal,\r\n  isDragging,\r\n  isTimelineDragging,\r\n  setIsTimelineDragging,\r\n  isResizing,\r\n  setIsResizing,\r\n  copiedItem,\r\n  formatTime,\r\n  seekTo,\r\n  splitTimelineItem,\r\n  copyTimelineItem,\r\n  pasteTimelineItem,\r\n  deleteSelectedItem,\r\n  addToTimeline,\r\n  insertWithRipple,\r\n  applyRippleEffect,\r\n  onSmartAddToTimeline,\r\n}) => {\r\n  const timelineRef = useRef(null);\r\n  const timelineScrollRef = useRef(null);\r\n  const trackLabelsRef = useRef(null);\r\n  const autoScrollIntervalRef = useRef(null);\r\n  const [dragOffset, setDragOffset] = useState(0);\r\n  const [resizeHandle, setResizeHandle] = useState(null);\r\n  const [resizeItem, setResizeItem] = useState(null);\r\n  const [originalItemData, setOriginalItemData] = useState(null);\r\n\r\n  const handleVolumeChange = useCallback(\r\n    (itemId, volumeDecimal) => {\r\n      console.log(\"Volume changed:\", itemId, volumeDecimal);\r\n\r\n      // Обновляем состояние timeline items\r\n      setTimelineItems((items) =>\r\n        items.map((item) =>\r\n          item.id === itemId\r\n            ? { ...item, volume: volumeDecimal } // Сохраняем как десятичное значение 0-1\r\n            : item\r\n        )\r\n      );\r\n\r\n      // Применяем volume к audio элементам\r\n      const audioElement = audioElementsRef.current.get(itemId);\r\n      if (audioElement) {\r\n        audioElement.volume = volumeDecimal * volume; // Умножаем на общий volume\r\n        console.log(\r\n          `✅ Applied volume ${volumeDecimal * volume} to audio ${itemId}`\r\n        );\r\n      }\r\n\r\n      // Применяем volume к video элементу (если это main video)\r\n      const item = timelineItems.find((t) => t.id === itemId);\r\n      if (item && item.trackType === \"main\" && videoRef.current) {\r\n        videoRef.current.volume = volumeDecimal * volume;\r\n        console.log(\r\n          `✅ Applied volume ${volumeDecimal * volume} to main video`\r\n        );\r\n      }\r\n    },\r\n    [timelineItems, volume]\r\n  );\r\n  const stopAutoScroll = useCallback(() => {\r\n    if (autoScrollIntervalRef.current) {\r\n      clearInterval(autoScrollIntervalRef.current);\r\n      autoScrollIntervalRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const startAutoScroll = useCallback(\r\n    (direction, speed = 1) => {\r\n      stopAutoScroll();\r\n\r\n      autoScrollIntervalRef.current = setInterval(() => {\r\n        if (timelineScrollRef.current) {\r\n          const scrollAmount = 15 * speed;\r\n          const currentScrollLeft = timelineScrollRef.current.scrollLeft;\r\n          const maxScroll =\r\n            timelineScrollRef.current.scrollWidth -\r\n            timelineScrollRef.current.clientWidth;\r\n\r\n          if (direction === \"left\" && currentScrollLeft > 0) {\r\n            timelineScrollRef.current.scrollLeft = Math.max(\r\n              0,\r\n              currentScrollLeft - scrollAmount\r\n            );\r\n          } else if (direction === \"right\" && currentScrollLeft < maxScroll) {\r\n            timelineScrollRef.current.scrollLeft = Math.min(\r\n              maxScroll,\r\n              currentScrollLeft + scrollAmount\r\n            );\r\n          }\r\n        }\r\n      }, 16);\r\n    },\r\n    [stopAutoScroll]\r\n  );\r\n\r\n  const checkAutoScroll = useCallback(\r\n    (clientX) => {\r\n      if (!timelineScrollRef.current) return;\r\n\r\n      const rect = timelineScrollRef.current.getBoundingClientRect();\r\n      const scrollZoneWidth = 120;\r\n      const relativeX = clientX - rect.left;\r\n\r\n      if (\r\n        relativeX < scrollZoneWidth &&\r\n        timelineScrollRef.current.scrollLeft > 0\r\n      ) {\r\n        const speed = ((scrollZoneWidth - relativeX) / scrollZoneWidth) * 3;\r\n        startAutoScroll(\"left\", speed);\r\n      } else if (relativeX > rect.width - scrollZoneWidth) {\r\n        const maxScroll =\r\n          timelineScrollRef.current.scrollWidth -\r\n          timelineScrollRef.current.clientWidth;\r\n        if (timelineScrollRef.current.scrollLeft < maxScroll) {\r\n          const speed =\r\n            ((relativeX - (rect.width - scrollZoneWidth)) / scrollZoneWidth) *\r\n            3;\r\n          startAutoScroll(\"right\", speed);\r\n        }\r\n      } else {\r\n        stopAutoScroll();\r\n      }\r\n    },\r\n    [startAutoScroll, stopAutoScroll]\r\n  );\r\n\r\n  const getTargetTrackForType = useCallback(\r\n    (mediaType) => {\r\n      switch (mediaType) {\r\n        case \"videos\":\r\n          const mainTrack = tracks.main?.[0];\r\n          return mainTrack?.id;\r\n        case \"audios\":\r\n          const audioTrack = tracks.audio?.[0];\r\n          return audioTrack?.id;\r\n        case \"images\":\r\n          const overlayTrack = tracks.overlays?.[0];\r\n          return overlayTrack?.id;\r\n        default:\r\n          return tracks.main?.[0]?.id;\r\n      }\r\n    },\r\n    [tracks]\r\n  );\r\n\r\n  const findBestPositionForItem = useCallback(\r\n    (item, targetTrackId) => {\r\n      const duration = item.duration || (item.type === \"image\" ? 5 : 10);\r\n\r\n      const itemsOnTrack = timelineItems\r\n        .filter((timelineItem) => timelineItem.trackId === targetTrackId)\r\n        .sort((a, b) => a.startTime - b.startTime);\r\n\r\n      if (itemsOnTrack.length === 0) {\r\n        return currentTime;\r\n      }\r\n\r\n      const hasSpaceAtCurrentTime = !itemsOnTrack.some((existingItem) => {\r\n        const existingStart = existingItem.startTime;\r\n        const existingEnd = existingItem.startTime + existingItem.duration;\r\n        const newStart = currentTime;\r\n        const newEnd = currentTime + duration;\r\n        return !(newEnd <= existingStart || newStart >= existingEnd);\r\n      });\r\n\r\n      if (hasSpaceAtCurrentTime) {\r\n        return currentTime;\r\n      }\r\n\r\n      const lastItem = itemsOnTrack[itemsOnTrack.length - 1];\r\n      return lastItem.startTime + lastItem.duration;\r\n    },\r\n    [timelineItems, currentTime]\r\n  );\r\n\r\n  // Утилиты\r\n  const getTimelineWidth = () => {\r\n    const baseWidth = videoDuration * 50 * timelineZoom;\r\n    return Math.max(baseWidth, 2000);\r\n  };\r\n\r\n  const getPixelsPerSecond = () => {\r\n    return 50 * timelineZoom;\r\n  };\r\n\r\n  const getTrackColor = (trackType) => {\r\n    switch (trackType) {\r\n      case \"overlay\":\r\n        return \"bg-purple-500 border-purple-400\";\r\n      case \"main\":\r\n        return \"bg-blue-500 border-blue-400\";\r\n      case \"audio\":\r\n        return \"bg-green-500 border-green-400\";\r\n      default:\r\n        return \"bg-gray-500 border-gray-400\";\r\n    }\r\n  };\r\n\r\n  const getTimelineItemStyle = (item) => {\r\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\r\n    const trackIndex = allTracks.findIndex(\r\n      (track) => track.id === item.trackId\r\n    );\r\n    const pixelsPerSecond = getPixelsPerSecond();\r\n\r\n    return {\r\n      left: `${item.startTime * pixelsPerSecond}px`,\r\n      width: `${item.duration * pixelsPerSecond}px`,\r\n      top: `${trackIndex * 60 + 10}px`,\r\n    };\r\n  };\r\n\r\n  const getDropPreviewStyle = () => {\r\n    if (!dropPreview) return {};\r\n\r\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\r\n    const trackIndex = allTracks.findIndex(\r\n      (track) => track.id === dropPreview.trackId\r\n    );\r\n    const pixelsPerSecond = getPixelsPerSecond();\r\n\r\n    return {\r\n      left: `${dropPreview.time * pixelsPerSecond}px`,\r\n      width: `${dropPreview.duration * pixelsPerSecond}px`,\r\n      top: `${trackIndex * 60 + 10}px`,\r\n    };\r\n  };\r\n\r\n  const zoomIn = () => setTimelineZoom((prev) => Math.min(20, prev * 1.5));\r\n  const zoomOut = () => setTimelineZoom((prev) => Math.max(0.1, prev / 1.5));\r\n  const resetZoom = () => setTimelineZoom(1);\r\n\r\n  const addOverlayTrack = () => {\r\n    const newTrackId = `overlay-${Date.now()}`;\r\n    setTracks((prev) => ({\r\n      ...prev,\r\n      overlays: [\r\n        ...prev.overlays,\r\n        {\r\n          id: newTrackId,\r\n          name: `Overlay ${prev.overlays.length + 1}`,\r\n          type: \"overlay\",\r\n        },\r\n      ],\r\n    }));\r\n  };\r\n\r\n  const addAudioTrack = () => {\r\n    const newTrackId = `audio-${Date.now()}`;\r\n    setTracks((prev) => ({\r\n      ...prev,\r\n      audio: [\r\n        ...prev.audio,\r\n        {\r\n          id: newTrackId,\r\n          name: `Audio ${prev.audio.length + 1}`,\r\n          type: \"audio\",\r\n        },\r\n      ],\r\n    }));\r\n  };\r\n\r\n  const addToTimelineAtCurrentTime = useCallback(() => {\r\n    if (!draggedItem) return;\r\n\r\n    const targetTrackId = getTargetTrackForType(draggedItem.type);\r\n    if (!targetTrackId) return;\r\n\r\n    const bestPosition = findBestPositionForItem(draggedItem, targetTrackId);\r\n    addToTimeline(draggedItem, bestPosition, targetTrackId);\r\n  }, [\r\n    draggedItem,\r\n    getTargetTrackForType,\r\n    findBestPositionForItem,\r\n    addToTimeline,\r\n  ]);\r\n\r\n  const handleResizeStart = useCallback(\r\n    (e, item, handle) => {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n      setIsResizing(true);\r\n      setResizeHandle(handle);\r\n      setResizeItem(item);\r\n      setOriginalItemData({\r\n        startTime: item.startTime,\r\n        duration: item.duration,\r\n      });\r\n\r\n      setIsTimelineDragging(false);\r\n      setDraggedTimelineItem(null);\r\n    },\r\n    [setIsResizing, setIsTimelineDragging, setDraggedTimelineItem]\r\n  );\r\n\r\n  const handleResizeEnd = useCallback(() => {\r\n    setIsResizing(false);\r\n    setResizeHandle(null);\r\n    setResizeItem(null);\r\n    setOriginalItemData(null);\r\n    stopAutoScroll();\r\n  }, [setIsResizing, stopAutoScroll]);\r\n\r\n  const handleTimelineItemDragStart = (e, timelineItem) => {\r\n    if (isResizing) {\r\n      e.preventDefault();\r\n      return;\r\n    }\r\n\r\n    e.stopPropagation();\r\n    setDraggedTimelineItem(timelineItem);\r\n    setIsTimelineDragging(true);\r\n\r\n    const rect = timelineScrollRef.current.getBoundingClientRect();\r\n    const itemRect = e.target.getBoundingClientRect();\r\n    setDragOffset(\r\n      e.clientX - itemRect.left + timelineScrollRef.current.scrollLeft\r\n    );\r\n\r\n    e.dataTransfer.effectAllowed = \"move\";\r\n    e.dataTransfer.setData(\"text/plain\", \"\");\r\n  };\r\n\r\n  const handleTimelineItemDragEnd = () => {\r\n    setDraggedTimelineItem(null);\r\n    setDropPreview(null);\r\n    setIsTimelineDragging(false);\r\n    setDragOffset(0);\r\n    stopAutoScroll();\r\n  };\r\n\r\n  const handleTimelineClick = (e) => {\r\n    if (isDragging || isTimelineDragging || isResizing) return;\r\n\r\n    const rect = timelineScrollRef.current.getBoundingClientRect();\r\n    const clickX = e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\r\n    const pixelsPerSecond = getPixelsPerSecond();\r\n    const clickTime = clickX / pixelsPerSecond;\r\n    seekTo(clickTime);\r\n  };\r\n\r\n  const handleTimelineDoubleClick = useCallback(\r\n    (e) => {\r\n      if (isDragging || isTimelineDragging || isResizing || !draggedItem)\r\n        return;\r\n\r\n      const rect = timelineScrollRef.current.getBoundingClientRect();\r\n      const clickX =\r\n        e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\r\n      const pixelsPerSecond = getPixelsPerSecond();\r\n      const clickTime = clickX / pixelsPerSecond;\r\n\r\n      const targetTrackId = getTargetTrackForType(draggedItem.type);\r\n      if (targetTrackId) {\r\n        addToTimeline(draggedItem, clickTime, targetTrackId);\r\n      }\r\n    },\r\n    [\r\n      isDragging,\r\n      isTimelineDragging,\r\n      isResizing,\r\n      draggedItem,\r\n      getTargetTrackForType,\r\n      addToTimeline,\r\n    ]\r\n  );\r\n\r\n  const handleDragOver = (e) => {\r\n    if (!draggedItem && !draggedTimelineItem) return;\r\n\r\n    e.preventDefault();\r\n    e.dataTransfer.dropEffect = draggedItem ? \"copy\" : \"move\";\r\n\r\n    if (draggedTimelineItem || isResizing) {\r\n      checkAutoScroll(e.clientX);\r\n    }\r\n\r\n    const timelineRect = timelineScrollRef.current.getBoundingClientRect();\r\n    const dragX =\r\n      e.clientX -\r\n      timelineRect.left +\r\n      timelineScrollRef.current.scrollLeft -\r\n      (draggedTimelineItem ? dragOffset : 0);\r\n    const pixelsPerSecond = getPixelsPerSecond();\r\n    const dropTime = Math.max(0, dragX / pixelsPerSecond);\r\n\r\n    const dragY =\r\n      e.clientY - timelineRect.top + timelineScrollRef.current.scrollTop;\r\n    const trackHeight = 60;\r\n    const timeRulerHeight = 48;\r\n\r\n    const relativeY = dragY - timeRulerHeight;\r\n    const trackIndex = Math.floor(relativeY / trackHeight);\r\n\r\n    const allTracks = [...tracks.overlays, ...tracks.main, ...tracks.audio];\r\n    const targetTrack = allTracks[trackIndex];\r\n\r\n    if (draggedItem && targetTrack) {\r\n      const duration =\r\n        draggedItem.duration || (draggedItem.type === \"image\" ? 5 : 10);\r\n      const insertResult = insertWithRipple(targetTrack.id, dropTime, duration);\r\n\r\n      setDropPreview({\r\n        time: insertResult.time,\r\n        duration: duration,\r\n        trackId: targetTrack.id,\r\n        trackType: targetTrack.type,\r\n        isValid: true,\r\n        shouldRipple: insertResult.shouldRipple,\r\n        affectedItems: insertResult.affectedItems || [],\r\n      });\r\n    } else if (draggedTimelineItem && targetTrack) {\r\n      const insertResult = insertWithRipple(\r\n        targetTrack.id,\r\n        dropTime,\r\n        draggedTimelineItem.duration,\r\n        draggedTimelineItem.id\r\n      );\r\n\r\n      setDropPreview({\r\n        time: insertResult.time,\r\n        duration: draggedTimelineItem.duration,\r\n        trackId: targetTrack.id,\r\n        trackType: targetTrack.type,\r\n        isValid: true,\r\n        shouldRipple: insertResult.shouldRipple,\r\n        affectedItems: insertResult.affectedItems || [],\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleDrop = (e) => {\r\n    e.preventDefault();\r\n    stopAutoScroll();\r\n\r\n    if (!dropPreview && draggedItem) {\r\n      const targetTrackId = getTargetTrackForType(draggedItem.type);\r\n      if (targetTrackId) {\r\n        const bestPosition = findBestPositionForItem(\r\n          draggedItem,\r\n          targetTrackId\r\n        );\r\n        addToTimeline(draggedItem, bestPosition, targetTrackId);\r\n      }\r\n      setDropPreview(null);\r\n      setIsTimelineDragging(false);\r\n      return;\r\n    }\r\n\r\n    if ((!draggedItem && !draggedTimelineItem) || !dropPreview) return;\r\n\r\n    if (dropPreview.isValid) {\r\n      if (draggedItem) {\r\n        if (dropPreview.shouldRipple && dropPreview.affectedItems?.length > 0) {\r\n          applyRippleEffect(dropPreview.affectedItems, dropPreview.duration);\r\n        }\r\n        addToTimeline(draggedItem, dropPreview.time, dropPreview.trackId);\r\n      } else if (draggedTimelineItem) {\r\n        if (dropPreview.shouldRipple && dropPreview.affectedItems?.length > 0) {\r\n          applyRippleEffect(\r\n            dropPreview.affectedItems,\r\n            draggedTimelineItem.duration\r\n          );\r\n        }\r\n\r\n        setTimelineItems((prev) =>\r\n          prev.map((item) =>\r\n            item.id === draggedTimelineItem.id\r\n              ? {\r\n                  ...item,\r\n                  startTime: dropPreview.time,\r\n                  trackId: dropPreview.trackId,\r\n                  trackType: dropPreview.trackType,\r\n                }\r\n              : item\r\n          )\r\n        );\r\n\r\n        const newEndTime = dropPreview.time + draggedTimelineItem.duration;\r\n        if (newEndTime > videoDuration) {\r\n          setVideoDuration(newEndTime + 10);\r\n        }\r\n      }\r\n    }\r\n\r\n    setDropPreview(null);\r\n    setIsTimelineDragging(false);\r\n  };\r\n\r\n  const handleDragLeave = (e) => {\r\n    if (!timelineRef.current?.contains(e.relatedTarget)) {\r\n      setDropPreview(null);\r\n      stopAutoScroll();\r\n    }\r\n  };\r\n\r\n  const handleTrackAreaScroll = (e) => {\r\n    if (trackLabelsRef.current) {\r\n      trackLabelsRef.current.scrollTop = e.target.scrollTop;\r\n    }\r\n  };\r\n\r\n  const handleTrackLabelsScroll = (e) => {\r\n    if (timelineScrollRef.current) {\r\n      timelineScrollRef.current.scrollTop = e.target.scrollTop;\r\n    }\r\n  };\r\n\r\n  const handleWheel = useCallback(\r\n    (e) => {\r\n      if (e.ctrlKey) {\r\n        e.preventDefault();\r\n\r\n        if (!timelineScrollRef.current) return;\r\n\r\n        const rect = timelineScrollRef.current.getBoundingClientRect();\r\n        const mouseX =\r\n          e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\r\n        const currentPixelsPerSecond = 50 * timelineZoom;\r\n        const timeAtMouse = mouseX / currentPixelsPerSecond;\r\n\r\n        const zoomDirection = e.deltaY < 0 ? 1 : -1;\r\n        const zoomStep = 1.2;\r\n\r\n        setTimelineZoom((prevZoom) => {\r\n          let newZoom;\r\n          if (zoomDirection > 0) {\r\n            newZoom = Math.min(20, prevZoom * zoomStep);\r\n          } else {\r\n            newZoom = Math.max(0.1, prevZoom / zoomStep);\r\n          }\r\n\r\n          requestAnimationFrame(() => {\r\n            if (timelineScrollRef.current) {\r\n              const newPixelsPerSecond = 50 * newZoom;\r\n              const newMouseX = timeAtMouse * newPixelsPerSecond;\r\n              const targetScrollLeft = newMouseX - (e.clientX - rect.left);\r\n              timelineScrollRef.current.scrollLeft = Math.max(\r\n                0,\r\n                targetScrollLeft\r\n              );\r\n            }\r\n          });\r\n\r\n          return newZoom;\r\n        });\r\n      } else if (e.shiftKey) {\r\n        e.preventDefault();\r\n\r\n        if (timelineScrollRef.current) {\r\n          const scrollAmount = e.deltaY * 2;\r\n          timelineScrollRef.current.scrollLeft += scrollAmount;\r\n        }\r\n      }\r\n    },\r\n    [timelineZoom, setTimelineZoom]\r\n  );\r\n\r\n  const smartAddToTimeline = useCallback(\r\n    (item, specifiedTime = null, specifiedTrackId = null) => {\r\n      if (specifiedTime !== null && specifiedTrackId !== null) {\r\n        addToTimeline(item, specifiedTime, specifiedTrackId);\r\n        return;\r\n      }\r\n\r\n      const targetTrackId =\r\n        specifiedTrackId || getTargetTrackForType(item.type);\r\n      if (!targetTrackId) {\r\n        console.error(`Не найдена подходящая дорожка для типа ${item.type}`);\r\n        return;\r\n      }\r\n\r\n      const bestPosition =\r\n        specifiedTime !== null\r\n          ? specifiedTime\r\n          : findBestPositionForItem(item, targetTrackId);\r\n\r\n      addToTimeline(item, bestPosition, targetTrackId);\r\n    },\r\n    [addToTimeline, getTargetTrackForType, findBestPositionForItem]\r\n  );\r\n\r\n  useEffect(() => {\r\n    const handleMouseMove = (e) => {\r\n      if (!isResizing || !resizeItem || !timelineScrollRef.current) return;\r\n\r\n      checkAutoScroll(e.clientX);\r\n\r\n      const rect = timelineScrollRef.current.getBoundingClientRect();\r\n      const mouseX =\r\n        e.clientX - rect.left + timelineScrollRef.current.scrollLeft;\r\n      const pixelsPerSecond = getPixelsPerSecond();\r\n      const newTime = mouseX / pixelsPerSecond;\r\n\r\n      setTimelineItems((prev) =>\r\n        prev.map((item) => {\r\n          if (item.id !== resizeItem.id) return item;\r\n\r\n          const minDuration = 0.1;\r\n\r\n          if (resizeHandle === \"left\") {\r\n            const rightEdge =\r\n              originalItemData.startTime + originalItemData.duration;\r\n            const newStartTime = Math.max(\r\n              0,\r\n              Math.min(rightEdge - minDuration, newTime)\r\n            );\r\n            const newDuration = rightEdge - newStartTime;\r\n\r\n            return {\r\n              ...item,\r\n              startTime: newStartTime,\r\n              duration: newDuration,\r\n            };\r\n          } else if (resizeHandle === \"right\") {\r\n            const leftEdge = originalItemData.startTime;\r\n            const newEndTime = Math.max(leftEdge + minDuration, newTime);\r\n            const newDuration = newEndTime - leftEdge;\r\n\r\n            return {\r\n              ...item,\r\n              duration: newDuration,\r\n            };\r\n          }\r\n\r\n          return item;\r\n        })\r\n      );\r\n    };\r\n\r\n    const handleMouseUp = () => {\r\n      if (isResizing) {\r\n        handleResizeEnd();\r\n      }\r\n    };\r\n\r\n    if (isResizing) {\r\n      document.addEventListener(\"mousemove\", handleMouseMove);\r\n      document.addEventListener(\"mouseup\", handleMouseUp);\r\n    }\r\n\r\n    return () => {\r\n      document.removeEventListener(\"mousemove\", handleMouseMove);\r\n      document.removeEventListener(\"mouseup\", handleMouseUp);\r\n    };\r\n  }, [\r\n    isResizing,\r\n    resizeItem,\r\n    resizeHandle,\r\n    originalItemData,\r\n    getPixelsPerSecond,\r\n    checkAutoScroll,\r\n    handleResizeEnd,\r\n    setTimelineItems,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    if (onSmartAddToTimeline) {\r\n      onSmartAddToTimeline(smartAddToTimeline);\r\n    }\r\n  }, [onSmartAddToTimeline, smartAddToTimeline]);\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      stopAutoScroll();\r\n    };\r\n  }, [stopAutoScroll]);\r\n\r\n  return (\r\n    <div\r\n      className={`h-80 bg-white rounded-2xl shadow-sm border-2 transition-all duration-200 overflow-hidden flex flex-col flex-shrink-0 ${\r\n        isDragging || isTimelineDragging || isResizing\r\n          ? \"border-blue-400 bg-blue-50/20\"\r\n          : \"border-gray-200\"\r\n      }`}\r\n      onWheel={handleWheel}\r\n    >\r\n      <TimelineHeader\r\n        draggedItem={draggedItem}\r\n        isDragging={isDragging}\r\n        isTimelineDragging={isTimelineDragging}\r\n        isResizing={isResizing}\r\n        setShowExportModal={setShowExportModal}\r\n        dropPreview={dropPreview}\r\n        draggedTimelineItem={draggedTimelineItem}\r\n        resizeItem={resizeItem}\r\n        resizeHandle={resizeHandle}\r\n        copiedItem={copiedItem}\r\n        timelineZoom={timelineZoom}\r\n        selectedTimelineItem={selectedTimelineItem}\r\n        addOverlayTrack={addOverlayTrack}\r\n        addAudioTrack={addAudioTrack}\r\n        addToTimelineAtCurrentTime={addToTimelineAtCurrentTime}\r\n        splitTimelineItem={splitTimelineItem}\r\n        copyTimelineItem={copyTimelineItem}\r\n        pasteTimelineItem={pasteTimelineItem}\r\n        deleteSelectedItem={deleteSelectedItem}\r\n        zoomIn={zoomIn}\r\n        zoomOut={zoomOut}\r\n        resetZoom={resetZoom}\r\n      />\r\n\r\n      <div className=\"flex-1 flex min-h-0\">\r\n        <TrackLabels\r\n          tracks={tracks}\r\n          trackLabelsRef={trackLabelsRef}\r\n          onScroll={handleTrackLabelsScroll}\r\n        />\r\n\r\n        <TimelineCanvas\r\n          timelineRef={timelineRef}\r\n          timelineScrollRef={timelineScrollRef}\r\n          tracks={tracks}\r\n          onVolumeChange={handleVolumeChange}\r\n          showVolumeControls={true}\r\n          timelineItems={timelineItems}\r\n          selectedTimelineItem={selectedTimelineItem}\r\n          draggedTimelineItem={draggedTimelineItem}\r\n          copiedItem={copiedItem}\r\n          dropPreview={dropPreview}\r\n          getTimelineWidth={getTimelineWidth}\r\n          getPixelsPerSecond={getPixelsPerSecond}\r\n          getTrackColor={getTrackColor}\r\n          getTimelineItemStyle={getTimelineItemStyle}\r\n          getDropPreviewStyle={getDropPreviewStyle}\r\n          videoDuration={videoDuration}\r\n          timelineZoom={timelineZoom}\r\n          currentTime={currentTime}\r\n          formatTime={formatTime}\r\n          onScroll={handleTrackAreaScroll}\r\n          onDragOver={handleDragOver}\r\n          onDrop={handleDrop}\r\n          onDragLeave={handleDragLeave}\r\n          onClick={handleTimelineClick}\r\n          onDoubleClick={handleTimelineDoubleClick}\r\n          onTimelineItemSelect={setSelectedTimelineItem}\r\n          onTimelineItemDragStart={handleTimelineItemDragStart}\r\n          onTimelineItemDragEnd={handleTimelineItemDragEnd}\r\n          onResizeStart={handleResizeStart}\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}